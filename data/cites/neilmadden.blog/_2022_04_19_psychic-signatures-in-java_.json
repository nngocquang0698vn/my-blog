{
  "type" : [ "h-entry" ],
  "properties" : {
    "name" : [ "CVE-2022-21449: Psychic Signatures in Java" ],
    "category" : [ "cryptography", "security", "api-security", "cryptography", "java", "jose", "jwt", "web-security" ],
    "url" : [ "https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/" ],
    "published" : [ "2022-04-19T21:10:00+01:00" ],
    "updated" : [ "2022-04-20T11:30:22+01:00" ],
    "content" : [ {
      "html" : "<p>The long-running BBC sci-fi show <a href=\"https://en.wikipedia.org/wiki/Doctor_Who\"><em>Doctor Who</em></a> has a recurring plot device where the Doctor manages to get out of trouble by showing an identity card which is actually completely blank. Of course, this being Doctor Who, the card is really made out of a special &#x201C;<a href=\"https://tardis.fandom.com/wiki/Psychic_paper\">psychic paper</a>&#x201C;, which causes the person looking at it to see whatever the Doctor wants them to see: a security pass, a warrant, or whatever.</p>\n\n\n\n<figure class=\"wp-block-image size-large is-resized\"><a href=\"https://tardis.fandom.com/wiki/Psychic_paper?file=Psychic_paper_DW_Shakespeare_Code.jpg\"><img loading=\"lazy\" data-attachment-id=\"3723\" data-permalink=\"https://neilmadden.blog/psychic_paper_dw_shakespeare_code/\" data-orig-file=\"https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg\" data-orig-size=\"700,401\" data-comments-opened=\"1\" data-image-meta='{\"aperture\":\"0\",\"credit\":\"\",\"camera\":\"\",\"caption\":\"\",\"created_timestamp\":\"0\",\"copyright\":\"\",\"focal_length\":\"0\",\"iso\":\"0\",\"shutter_speed\":\"0\",\"title\":\"\",\"orientation\":\"1\"}' data-image-title=\"psychic_paper_dw_shakespeare_code\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=300\" data-large-file=\"https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=700\" src=\"https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=700\" alt=\"Doctor Who holding up a blank ID card with a badly superimposed image of Duke (the Java mascot) holding a glass of wine.\" class=\"wp-image-3723\" width=\"630\" height=\"360\" srcset=\"\" sizes=\"(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px\"></a><figcaption>&#x201C;Looks legit to me. <a href=\"https://images.app.goo.gl/1cgL8VJRpaAGaEnm9\">Hic!</a>&#x201C;</figcaption></figure>\n\n\n\n<p>It turns out that some recent releases of Java were vulnerable to a similar kind of trick, in the implementation of widely-used <a href=\"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm\">ECDSA</a> signatures. If you are running one of the vulnerable versions then an attacker can easily forge some types of SSL certificates and handshakes (allowing interception and modification of communications), <a href=\"https://jwt.io/\">signed JWTs</a>, <a href=\"https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language\">SAML assertions</a> or <a href=\"https://en.wikipedia.org/wiki/OpenID#OpenID_Connect_(OIDC)\">OIDC id tokens</a>, and even <a href=\"https://webauthn.guide/\">WebAuthn</a> authentication messages. All using the digital equivalent of a blank piece of paper.</p>\n\n\n\n<p>It&#x2019;s hard to overstate the severity of this bug. If you are using ECDSA signatures for any of these security mechanisms, then an attacker can <em>trivially and completely bypass them</em> if your server is running any Java 15, 16, 17, or 18 version before the <a href=\"https://www.oracle.com/security-alerts/cpuapr2022.html\">April 2022 Critical Patch Update (CPU)</a>. For context, almost all WebAuthn/FIDO devices in the real world (including Yubikeys<a href=\"https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/#footnote-1\">*</a>) use ECDSA signatures and many OIDC providers use ECDSA-signed JWTs.</p>\n\n\n\n<p><strong>If you have deployed Java 15, Java 16, Java 17, or Java 18 in production then you should stop what you are doing and immediately update to install the fixes in the <a href=\"https://www.oracle.com/security-alerts/cpuapr2022.html\">April 2022 Critical Patch Update</a>.</strong></p>\n\n\n\n<p><strong>Update</strong>: the official announcement from Oracle also lists older versions of Java, including 7 and 8. Although I&#x2019;m not aware of the bug impacting those older implementations they did fix a similar bug in the (non-EC) DSA implementation at the same time, so it&#x2019;s possible older versions are also impacted. There are also other security vulnerabilities reported in the same CPU, so (as always) it is worth upgrading even if you are running an older Java version.</p>\n\n\n\n<span id=\"more-3721\"></span>\n\n\n\n<p>Oracle have given this a CVSS score of 7.5, assigning no impact to Confidentiality or Availability. Internally, we at ForgeRock graded this <a href=\"https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H\">a perfect 10.0</a> due to the wide range of impacts on different functionality in an access management context. ForgeRock customers can <a href=\"https://backstage.forgerock.com/knowledge/kb/article/a90257583\">read our advisory about this issue</a> for further guidance.</p>\n\n\n\n<h2>Background: ECDSA signatures</h2>\n\n\n\n<p>ECDSA stands for the <a href=\"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm\">Elliptic Curve Digital Signature Algorithm</a>, and it is a widely used standard for signing all kinds of digital documents. Compared to the older RSA standard, elliptic curve keys and signatures tend to be much smaller for equivalent security, resulting in them being widely used in cases where size is at a premium. For example, the WebAuthn standard for two-factor authentication allows device manufacturers to choose from a wide range of signature algorithms, but in practice almost all of the devices manufactured to date support ECDSA signatures only (a notable exception being Windows Hello, which uses RSA signatures; presumably for compatibility with older <a href=\"https://support.microsoft.com/en-us/topic/what-is-tpm-705f241d-025d-4470-80c5-4feeb24fa1ee\">TPM</a> hardware).</p>\n\n\n\n<p>Without getting too much into the technical details, an ECDSA signature consists of two values, called <em>r</em> and <em>s</em>. To <a href=\"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm\">verify an ECDSA signature</a>, the verifier checks an equation involving <em>r</em>, <em>s</em>, the signer&#x2019;s public key, and a hash of the message. If the two sides of the equation are equal then the signature is valid, otherwise it is rejected.&#xA0;</p>\n\n\n\n<p>One side of the equation is <em>r</em> and the other side is multiplied by <em>r </em>and a value derived from <em>s</em>. So it would obviously be a really bad thing if <em>r</em> and <em>s</em> were both 0, because then you&#x2019;d be checking that 0 = 0 &#x2A09; <em>[a bunch of stuff]</em>, which will be true regardless of the value of <em>[a bunch of stuff]</em>! And that bunch of stuff is the important bits like the message and the public key. This is why the very first check in the ECDSA verification algorithm is to ensure that <em>r</em> and <em>s</em> are both &gt;= 1.</p>\n\n\n\n<p>Guess which check Java forgot?</p>\n\n\n\n<p>That&#x2019;s right. Java&#x2019;s implementation of ECDSA signature verification didn&#x2019;t check if r or s were zero, so you could produce a signature value in which they are both 0 (<a href=\"https://en.wikipedia.org/wiki/ASN.1\">appropriately encoded</a>) and Java would accept it as a valid signature for any message and for any public key. The digital equivalent of a blank ID card.</p>\n\n\n\n<p>Here&#x2019;s an interactive jshell session showing the vulnerable implementation accepting a completely blank signature as valid for an arbitrary message and public key:</p>\n\n\n\n<pre class=\"wp-block-code\"><code>|  Welcome to JShell -- Version 17.0.1\n|  For an introduction type: /help intro\njshell&gt; <strong>import java.security.*</strong>\njshell&gt; <strong>var keys = KeyPairGenerator.getInstance(\"EC\").generateKeyPair()</strong>\nkeys ==&gt; java.security.KeyPair@626b2d4a\njshell&gt; <strong>var blankSignature = new byte[64]</strong>\nblankSignature ==&gt; byte[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... , 0, 0, 0, 0, 0, 0, 0, 0 }\njshell&gt; <strong>var sig = Signature.getInstance(\"SHA256WithECDSAInP1363Format\")</strong>\nsig ==&gt; Signature object: SHA256WithECDSAInP1363Format&lt;not initialized&gt;\njshell&gt; <strong>sig.initVerify(keys.getPublic())</strong>\njshell&gt; <strong>sig.update(\"Hello, World\".getBytes())</strong>\njshell&gt; <strong>sig.verify(blankSignature)</strong>\n$8 ==&gt; true\n// Oops, that shouldn't have verified...</code></pre>\n\n\n\n<p>Note that the &#x201C;InP1363Format&#x201D; qualifier just makes it easier to demonstrate the bug. Signatures in ASN.1 DER format can be exploited in the same way, you just have to do a bit more fiddling with the encoding first, but note that JWTs and other formats do use the raw IEEE P1363 format.</p>\n\n\n\n<h3>A few technical details</h3>\n\n\n\n<p>If you go and look at the fine details of ECDSA on wikipedia, you&#x2019;ll see that the right hand side of the equation is not multiplied by <em>s</em> but rather by its multiplicative inverse: <em>s</em><sup>-1</sup>. If you know a little maths, you may be thinking &#x201C;won&#x2019;t calculating this inverse result in a division by zero?&#x201D; But in elliptic curve cryptography, this inverse is being calculated modulo a large number, <em>n</em>, and for the curves typically used in ECDSA, <em>n</em> is a prime number so we can use the <a href=\"https://en.wikipedia.org/wiki/Fermat's_little_theorem\">Little Theorem</a> of Fermat (vandalizer of margins) to calculate the modular inverse:</p>\n\n\n\n<p class=\"has-text-align-center\">x<sup>n</sup> = x<sup>1</sup> = x           (mod n)<br>x<sup>(n-1)</sup> = x<sup>0</sup> = 1     (mod n)<br>x<sup>(n-2)</sup> = x<sup>-1</sup>         (mod n)</p>\n\n\n\n<p>This is very efficient, and it&#x2019;s <a href=\"https://github.com/openjdk/jdk/blob/ec205f68a883cef6b98f26a06baf675f7da26928/src/java.base/share/classes/sun/security/util/math/IntegerModuloP.java#L158\">exactly what Java does</a>. However, it is only valid for when x is not zero, as zero doesn&#x2019;t have a multiplicative inverse. When x is zero then 0<sup>(n-2)</sup> = 0: garbage in, garbage out.</p>\n\n\n\n<p>The fact that arithmetic is carried out modulo <em>n</em> is also why you need to check that <em>r</em> and <em>s</em> are both &lt;<em> n</em> too, because <em>n</em> = 0 (mod n) so setting<em> r</em> or <em>s</em> to <em>n</em> would have the same effect as setting them to 0.</p>\n\n\n\n<p>Another check that should&#x2019;ve saved Java is the check described in step 5 of the verification algorithm on Wikipedia: checking that a point calculated from <em>r</em> and <em>s</em> is not the &#x201C;point at infinity&#x201D;. If <em>r</em> and <em>s</em> are both zero, then the resulting point will in fact be the point at infinity and so this check will fail. But again, Java failed to perform this check.</p>\n\n\n\n<h2>Why did you just find this now?</h2>\n\n\n\n<p>You may be wondering why this is just coming to light now, when Java has had ECDSA support for a long time. Has it always been vulnerable?</p>\n\n\n\n<p>No. This is a relatively recent bug introduced by a rewrite of the EC code from native C++ code to Java, <a href=\"https://bugs.openjdk.java.net/browse/JDK-8237218\">which happened in the Java 15 release</a>. Although I&#x2019;m sure that this rewrite has benefits in terms of memory safety and maintainability, it appears that experienced cryptographic engineers have not been involved in the implementation. The original C++ implementation<a href=\"https://github.com/openjdk/jdk/blob/jdk-15-ga/src/jdk.crypto.ec/share/native/libsunec/impl/ec.c#L956\"> is not vulnerable to these bugs</a>, but the rewrite was. Neither implementation appears to have very good test coverage, and even the most cursory reading of the ECDSA spec would surely suggest testing that invalid r and s values are rejected. I am not at all confident that other bugs aren&#x2019;t lurking in this code.</p>\n\n\n\n<h2>What should we do about it?</h2>\n\n\n\n<p>First of all, if you are using Java 15 or later then please go and update to the latest version to get the fix for this issue.</p>\n\n\n\n<p>In general, cryptographic code is very tricky to implement correctly and public key signature algorithms are some of the trickiest. ECDSA is itself one of the most fragile algorithms, where <a href=\"https://eprint.iacr.org/2020/615\">even a tiny amount of bias in one random value can allow complete recovery of your private key</a>. On the other hand, we now have excellent resources like <a href=\"https://github.com/google/wycheproof\">Project Wycheproof</a> that provide test cases for known vulnerabilities. After I found this bug I updated a local copy of Wycheproof to run against Java 17 &#x2013; it found this issue immediately. Hopefully the JDK team will adopt the Wycheproof test suite themselves to avoid any similar bugs slipping through the net in future.</p>\n\n\n\n<p>If you are designing a protocol or application that you think needs to use digital signatures, consider if you really do &#x2013; would a simpler mechanism work instead? Simple MAC algorithms like <a href=\"https://en.wikipedia.org/wiki/HMAC\">HMAC</a> are incredibly hard to mess up compared to signature schemes. If you really need a signature then consider using a modern algorithm like <a href=\"https://www.rfc-editor.org/rfc/rfc8032.html\">EdDSA</a> that avoids some of the pitfalls of ECDSA.</p>\n\n\n\n<h2>Timeline</h2>\n\n\n\n<p><em>11 Nov 2021</em> &#x2013; Issue found and disclosed to OpenJDK vulnerability report email address.</p>\n\n\n\n<p><em>11</em> <em>Nov 2021</em> &#x2013; Determined <a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8237218\">JDK change</a> that introduced the bug in Java 15.</p>\n\n\n\n<p><em>12 Nov 2021</em> &#x2013; Initial acknowledgement from Oracle.</p>\n\n\n\n<p><em>18 Nov 2021</em> &#x2013; Oracle confirms the bug and indicates it will be patched in a future Critical Patch Update (CPU). It is assigned tracking ID S1559193.</p>\n\n\n\n<p><em>18 Nov 2021</em> &#x2013; ForgeRock <a href=\"https://backstage.forgerock.com/knowledge/kb/article/a90257583\">issues a security advisory</a> informing our customers not to deploy affected versions of Java into production.</p>\n\n\n\n<p><em>14 Jan 2022</em> &#x2013; Ask Oracle for status update. Told that the fix is targeting the April 2022 CPU, scheduled for 19th April.</p>\n\n\n\n<p><em>25 Mar 2022</em> &#x2013; Confirm again with Oracle that the fix will be in April CPU. Inform them that ForgeRock will proceed to full disclosure if the bug is not fixed by then.</p>\n\n\n\n<p><em>19 Apr 2022</em> &#x2013; Fix released by Oracle in April CPU.</p>\n\n\n\n<p><em>19 Apr 2022</em> &#x2013; Article published.</p>\n\n\n\n<p id=\"footnote-1\">* Yubico is one of the few WebAuthn manufacturers that support the more secure <a href=\"https://www.rfc-editor.org/rfc/rfc8032.html\">EdDSA</a> standard in addition to ECDSA. EdDSA signatures are less prone to the type of bug described here.</p>\n<div id=\"jp-post-flair\" class=\"sharedaddy sd-like-enabled sd-sharing-enabled\"><div class=\"sharedaddy sd-sharing-enabled\"><div class=\"robots-nocontent sd-block sd-social sd-social-icon sd-sharing\"><h3 class=\"sd-title\">Share this:</h3><div class=\"sd-content\"><ul><li class=\"share-email\"><a rel=\"nofollow noopener noreferrer\" data-shared=\"\" class=\"share-email sd-button share-icon no-text\" href=\"https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/?share=email\" target=\"_blank\" title=\"Click to email this to a friend\"><span></span><span class=\"sharing-screen-reader-text\">Click to email this to a friend (Opens in new window)</span></a></li><li class=\"share-print\"><a rel=\"nofollow noopener noreferrer\" data-shared=\"\" class=\"share-print sd-button share-icon no-text\" href=\"https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/#print\" target=\"_blank\" title=\"Click to print\"><span></span><span class=\"sharing-screen-reader-text\">Click to print (Opens in new window)</span></a></li><li class=\"share-facebook\"><a rel=\"nofollow noopener noreferrer\" data-shared=\"sharing-facebook-3721\" class=\"share-facebook sd-button share-icon no-text\" href=\"https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/?share=facebook\" target=\"_blank\" title=\"Click to share on Facebook\"><span></span><span class=\"sharing-screen-reader-text\">Click to share on Facebook (Opens in new window)</span></a></li><li class=\"share-reddit\"><a rel=\"nofollow noopener noreferrer\" data-shared=\"\" class=\"share-reddit sd-button share-icon no-text\" href=\"https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/?share=reddit\" target=\"_blank\" title=\"Click to share on Reddit\"><span></span><span class=\"sharing-screen-reader-text\">Click to share on Reddit (Opens in new window)</span></a></li><li class=\"share-linkedin\"><a rel=\"nofollow noopener noreferrer\" data-shared=\"sharing-linkedin-3721\" class=\"share-linkedin sd-button share-icon no-text\" href=\"https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/?share=linkedin\" target=\"_blank\" title=\"Click to share on LinkedIn\"><span></span><span class=\"sharing-screen-reader-text\">Click to share on LinkedIn (Opens in new window)</span></a></li><li class=\"share-end\"></ul></div></div></div><div class=\"sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-unloaded\" id=\"like-post-wrapper-3754709-3721-625ff06fb3ccf\" data-src=\"//widgets.wp.com/likes/index.html?ver=20220105#blog_id=3754709&amp;post_id=3721&amp;origin=neilmadden.wordpress.com&amp;obj_id=3754709-3721-625ff06fb3ccf&amp;domain=neilmadden.blog\" data-name=\"like-post-frame-3754709-3721-625ff06fb3ccf\" data-title=\"Like or Reblog\"><h3 class=\"sd-title\">Like this:</h3><div class=\"likes-widget-placeholder post-likes-widget-placeholder\" style=\"height: 55px;\"><span class=\"button\"><span>Like</span></span> <span class=\"loading\">Loading...</span></div><span class=\"sd-text-color\"></span><a class=\"sd-link-color\"></a></div>\n<div id=\"jp-relatedposts\" class=\"jp-relatedposts\">\n\t<h3 class=\"jp-relatedposts-headline\"><em>Related</em></h3>\n</div></div>\n<div class=\"author-info\">\n\t<div class=\"author-avatar\">\n\t\t\t</div><!-- .author-avatar -->\n\n\t<div class=\"author-description\">\n\t\t<h2 class=\"author-title\"><span class=\"author-heading\">Author:</span> Neil Madden</h2>\n\n\t\t<p class=\"author-bio\">\n\t\t\tSecurity Architect at ForgeRock. Experienced software engineer with a PhD in computer science. Interested in application security, applied cryptography, logic programming and intelligent agents.\t\t\t<a class=\"author-link\" href=\"https://neilmadden.blog/author/neilmadden/\" rel=\"author\">\n\t\t\t\tView all posts by Neil Madden\t\t\t</a>\n\t\t</p><!-- .author-bio -->\n\t</div><!-- .author-description -->\n</div><!-- .author-info -->",
      "value" : "The long-running BBC sci-fi show Doctor Who has a recurring plot device where the Doctor manages to get out of trouble by showing an identity card which is actually completely blank. Of course, this being Doctor Who, the card is really made out of a special “psychic paper“, which causes the person looking at it to see whatever the Doctor wants them to see: a security pass, a warrant, or whatever. Doctor Who holding up a blank ID card with a badly superimposed image of Duke (the Java mascot) holding a glass of wine. “Looks legit to me. Hic!“\nIt turns out that some recent releases of Java were vulnerable to a similar kind of trick, in the implementation of widely-used ECDSA signatures. If you are running one of the vulnerable versions then an attacker can easily forge some types of SSL certificates and handshakes (allowing interception and modification of communications), signed JWTs, SAML assertions or OIDC id tokens, and even WebAuthn authentication messages. All using the digital equivalent of a blank piece of paper.\nIt’s hard to overstate the severity of this bug. If you are using ECDSA signatures for any of these security mechanisms, then an attacker can trivially and completely bypass them if your server is running any Java 15, 16, 17, or 18 version before the April 2022 Critical Patch Update (CPU). For context, almost all WebAuthn/FIDO devices in the real world (including Yubikeys*) use ECDSA signatures and many OIDC providers use ECDSA-signed JWTs.\nIf you have deployed Java 15, Java 16, Java 17, or Java 18 in production then you should stop what you are doing and immediately update to install the fixes in the April 2022 Critical Patch Update.\nUpdate: the official announcement from Oracle also lists older versions of Java, including 7 and 8. Although I’m not aware of the bug impacting those older implementations they did fix a similar bug in the (non-EC) DSA implementation at the same time, so it’s possible older versions are also impacted. There are also other security vulnerabilities reported in the same CPU, so (as always) it is worth upgrading even if you are running an older Java version.\nOracle have given this a CVSS score of 7.5, assigning no impact to Confidentiality or Availability. Internally, we at ForgeRock graded this a perfect 10.0 due to the wide range of impacts on different functionality in an access management context. ForgeRock customers can read our advisory about this issue for further guidance. Background: ECDSA signatures\nECDSA stands for the Elliptic Curve Digital Signature Algorithm, and it is a widely used standard for signing all kinds of digital documents. Compared to the older RSA standard, elliptic curve keys and signatures tend to be much smaller for equivalent security, resulting in them being widely used in cases where size is at a premium. For example, the WebAuthn standard for two-factor authentication allows device manufacturers to choose from a wide range of signature algorithms, but in practice almost all of the devices manufactured to date support ECDSA signatures only (a notable exception being Windows Hello, which uses RSA signatures; presumably for compatibility with older TPM hardware).\nWithout getting too much into the technical details, an ECDSA signature consists of two values, called r and s. To verify an ECDSA signature, the verifier checks an equation involving r, s, the signer’s public key, and a hash of the message. If the two sides of the equation are equal then the signature is valid, otherwise it is rejected. \nOne side of the equation is r and the other side is multiplied by r and a value derived from s. So it would obviously be a really bad thing if r and s were both 0, because then you’d be checking that 0 = 0 ⨉ [a bunch of stuff], which will be true regardless of the value of [a bunch of stuff]! And that bunch of stuff is the important bits like the message and the public key. This is why the very first check in the ECDSA verification algorithm is to ensure that r and s are both >= 1.\nGuess which check Java forgot?\nThat’s right. Java’s implementation of ECDSA signature verification didn’t check if r or s were zero, so you could produce a signature value in which they are both 0 (appropriately encoded) and Java would accept it as a valid signature for any message and for any public key. The digital equivalent of a blank ID card.\nHere’s an interactive jshell session showing the vulnerable implementation accepting a completely blank signature as valid for an arbitrary message and public key: | Welcome to JShell -- Version 17.0.1 | For an introduction type: /help intro jshell> import java.security.* jshell> var keys = KeyPairGenerator.getInstance(\"EC\").generateKeyPair() keys ==> java.security.KeyPair@626b2d4a jshell> var blankSignature = new byte[64] blankSignature ==> byte[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... , 0, 0, 0, 0, 0, 0, 0, 0 } jshell> var sig = Signature.getInstance(\"SHA256WithECDSAInP1363Format\") sig ==> Signature object: SHA256WithECDSAInP1363Format<not initialized> jshell> sig.initVerify(keys.getPublic()) jshell> sig.update(\"Hello, World\".getBytes()) jshell> sig.verify(blankSignature) $8 ==> true // Oops, that shouldn't have verified...\nNote that the “InP1363Format” qualifier just makes it easier to demonstrate the bug. Signatures in ASN.1 DER format can be exploited in the same way, you just have to do a bit more fiddling with the encoding first, but note that JWTs and other formats do use the raw IEEE P1363 format. A few technical details\nIf you go and look at the fine details of ECDSA on wikipedia, you’ll see that the right hand side of the equation is not multiplied by s but rather by its multiplicative inverse: s-1. If you know a little maths, you may be thinking “won’t calculating this inverse result in a division by zero?” But in elliptic curve cryptography, this inverse is being calculated modulo a large number, n, and for the curves typically used in ECDSA, n is a prime number so we can use the Little Theorem of Fermat (vandalizer of margins) to calculate the modular inverse:\nxn = x1 = x (mod n)\nx(n-1) = x0 = 1 (mod n)\nx(n-2) = x-1 (mod n)\nThis is very efficient, and it’s exactly what Java does. However, it is only valid for when x is not zero, as zero doesn’t have a multiplicative inverse. When x is zero then 0(n-2) = 0: garbage in, garbage out.\nThe fact that arithmetic is carried out modulo n is also why you need to check that r and s are both < n too, because n = 0 (mod n) so setting r or s to n would have the same effect as setting them to 0.\nAnother check that should’ve saved Java is the check described in step 5 of the verification algorithm on Wikipedia: checking that a point calculated from r and s is not the “point at infinity”. If r and s are both zero, then the resulting point will in fact be the point at infinity and so this check will fail. But again, Java failed to perform this check. Why did you just find this now?\nYou may be wondering why this is just coming to light now, when Java has had ECDSA support for a long time. Has it always been vulnerable?\nNo. This is a relatively recent bug introduced by a rewrite of the EC code from native C++ code to Java, which happened in the Java 15 release. Although I’m sure that this rewrite has benefits in terms of memory safety and maintainability, it appears that experienced cryptographic engineers have not been involved in the implementation. The original C++ implementation is not vulnerable to these bugs, but the rewrite was. Neither implementation appears to have very good test coverage, and even the most cursory reading of the ECDSA spec would surely suggest testing that invalid r and s values are rejected. I am not at all confident that other bugs aren’t lurking in this code. What should we do about it?\nFirst of all, if you are using Java 15 or later then please go and update to the latest version to get the fix for this issue.\nIn general, cryptographic code is very tricky to implement correctly and public key signature algorithms are some of the trickiest. ECDSA is itself one of the most fragile algorithms, where even a tiny amount of bias in one random value can allow complete recovery of your private key. On the other hand, we now have excellent resources like Project Wycheproof that provide test cases for known vulnerabilities. After I found this bug I updated a local copy of Wycheproof to run against Java 17 – it found this issue immediately. Hopefully the JDK team will adopt the Wycheproof test suite themselves to avoid any similar bugs slipping through the net in future.\nIf you are designing a protocol or application that you think needs to use digital signatures, consider if you really do – would a simpler mechanism work instead? Simple MAC algorithms like HMAC are incredibly hard to mess up compared to signature schemes. If you really need a signature then consider using a modern algorithm like EdDSA that avoids some of the pitfalls of ECDSA. Timeline\n11 Nov 2021 – Issue found and disclosed to OpenJDK vulnerability report email address.\n11 Nov 2021 – Determined JDK change that introduced the bug in Java 15.\n12 Nov 2021 – Initial acknowledgement from Oracle.\n18 Nov 2021 – Oracle confirms the bug and indicates it will be patched in a future Critical Patch Update (CPU). It is assigned tracking ID S1559193.\n18 Nov 2021 – ForgeRock issues a security advisory informing our customers not to deploy affected versions of Java into production.\n14 Jan 2022 – Ask Oracle for status update. Told that the fix is targeting the April 2022 CPU, scheduled for 19th April.\n25 Mar 2022 – Confirm again with Oracle that the fix will be in April CPU. Inform them that ForgeRock will proceed to full disclosure if the bug is not fixed by then.\n19 Apr 2022 – Fix released by Oracle in April CPU.\n19 Apr 2022 – Article published.\n* Yubico is one of the few WebAuthn manufacturers that support the more secure EdDSA standard in addition to ECDSA. EdDSA signatures are less prone to the type of bug described here. Share this:Click to email this to a friend (Opens in new window)Click to print (Opens in new window)Click to share on Facebook (Opens in new window)Click to share on Reddit (Opens in new window)Click to share on LinkedIn (Opens in new window)Like this:Like Loading... Related Author: Neil Madden\nSecurity Architect at ForgeRock. Experienced software engineer with a PhD in computer science. Interested in application security, applied cryptography, logic programming and intelligent agents. View all posts by Neil Madden",
      "lang" : "en"
    } ],
    "author" : [ {
      "type" : [ "h-card" ],
      "properties" : {
        "name" : [ "Neil Madden" ],
        "url" : [ "https://neilmadden.blog/author/neilmadden/" ]
      },
      "lang" : "en",
      "value" : "Neil Madden"
    } ]
  },
  "lang" : "en"
}
