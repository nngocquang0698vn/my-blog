{
  "type" : [ "h-entry" ],
  "properties" : {
    "name" : [ "Hosting a fun DNS server with Go and a DNS library" ],
    "category" : [ "Programming" ],
    "featured" : [ "https://jamesg.blog/assets/dnsserver.png" ],
    "syndication" : [ "https://news.indieweb.org/en" ],
    "url" : [ "https://jamesg.blog/2022/09/09/fun-with-dns/" ],
    "published" : [ "2022-09-09T00:00:00" ],
    "content" : [ {
      "html" : "<p><em><strong>TL;DR:</strong> I now have my own DNS resolver at @jamesg.blog with some fun utilities. Read the <a href=\"https://github.com/capjamesg/dns-experiments/blob/main/indieweb.go\">GitHub documentation</a> for a complete reference manual of all queries, and keep reading below for an explanation of the project and how it works.</em></p>\n<p>In this week's Homebrew Website Club, someone mentioned <a href=\"https://dns.toys\">dns.toys</a>, a set of playful tools including unit converters that are available by making a DNS query. I found this idea fascinating and I wanted to explore it a bit more. I learned more about how DNS resolution worked last month when reading about traceroute and how it works. I was left with an itch: how can I make something fun over DNS?</p>\n<p>When considering what to build, I thought: how about a temperature converter? The idea of a fully-offline, web-powered, free and private temperature conversion tool came up in HWC so unit conversion was top of mind. This project didn't aim to be fully offline or web powered though: DNS is a networking protocol, after all(!).</p>\n<p>To get started, I first went back to the <a href=\"https://github.com/miekg\">miekg/dns</a> Go library that I saw a while ago. This library implements, if I recall correctly, most if not all DNS Request for Comments documents. While I understand a bit about the inner workings of DNS, I didn't want this project to be too technical on that side of things. DNS is big. Beyond Tellerrand reminded me that I don't need to try to reinvent the wheel to make something cool. So I decided to worry less about low-level DNS and more about what I wanted to build.</p>\n<h2>Getting started</h2>\n<p>Building a temperature converter helped me get my foot in the door with this idea. I had a goal in mind, a library that would abstract away a lot of technical details, and a motivating factor: to build a cool DNS utility.</p>\n<p>My first goal was to build the core application logic. This logic:</p>\n<ol>\n<li>Initialises a DNS server object.</li>\n<li>Registers handlers for different resource names (i.e. \"is.it.hwc.day\").</li>\n<li>Starts the server.</li>\n</ol>\n<p>I started by writing a handler for temperature conversion, which took some time as I am newer to Go and I haven't worked a lot with floating point arithmatic. I learned about the float32 and float64 functions and I did some manipulation to convert the temperature numbers into strings and the resultant number that would be fed back in the DNS response into a string. I wrote this logic for both Celsius to Fahrenheit and Fahrenheit to Celsius.</p>\n<p>While building the temperature converter, I found the \".\" handler matches any query. I use this handler to check for a temperature query. If you query <code>fc100</code> my application recognises fc as Fahrenheit-to-Celsius and does the conversion on the next number. This involves a bit of string manipulation to remove the fc. Conversely, cf30 converts 30 degrees Celsius to Fahrenheit.</p>\n<p>When you run the application, the miekg/dns library creates a server. This server can be run locally and queried.</p>\n<p>Here's an example query made using dig:</p>\n<p><code>dig @jamesg.blog resource.name</code></p>\n<p>This tells dig to query the jamesg.blog DNS server. This server is opened publicly on port 53. But, my application doesn't host directly on port 53. Ports under 1024 are reserved. I would need to give Go special access to directly host applications on port 53. I didn't want to do this so I did some Googling and found an alternative: host the application on a different port internally and forward all traffic from port 53 to this application. I did this using iptables. I also opened up port 53 so you could make DNS queries to my server.</p>\n<p>All data from my application is sent via TXT records, which allow ASCII-only string contents.</p>\n<p>Locally, when testing, I could not use dig without specifying the port. I did this using this command:</p>\n<p><code>dig @localhost -p 5000 resource.name</code></p>\n<p>This makes a query for the resource <code>resource.name</code> on port 5000.</p>\n<h2>Adding new features</h2>\n<p>Next, I started exploring new features. I wondered: what else would be cool to show over DNS? I thought: how about some IndieWeb and personal website features? I decided to host a few TXT records with some information about projects I have worked on, available by querying the \"resume\" resource on my DNS server. Part of me wants to extend this to parse my h-resume and show my full resume over DNS. That is a project for another day. I also made the <code>recent.blog</code> query which gets the title and slug of the blog post I published most recently.</p>\n<p>I wrote three IndieWeb-related features:</p>\n<ol>\n<li>Check if it is HWC day (Wednesday).</li>\n<li>Check if it is Newsletter day (Friday).</li>\n<li>Retrieve the next event from <a href=\"https://events.indieweb.org\">events.indieweb.org</a>, if one is scheduled.</li>\n</ol>\n<p>The first two functions were simple. My application gets the current day of the week and returns a response depending on whether the current day of the week is equal to Wednesday for HWC day or Friday for newsletter day. The feature that retrieves the next event from the IndieWeb events page took more time to implement. I used the <a href=\"https://github.com/willnorris/microformats\">Go microformats parser</a> to parse the events page. Then, I go through all events from top to bottom. The first event that is after the current time is displayed as the next event. I don't order the events page in the application because events.indieweb.org is ordered by the most recent upcoming event first.</p>\n<p>Here's an example of a query to retrieve the next event from the IndieWeb events page:</p>\n<p><code>dig @jamesg.blog next.indieweb.event</code></p>\n<p>This query returns:</p>\n<p><code>next.indieweb.event.    0   IN  TXT \"IndieWeb Create Day - 2022-09-18 09:00:00 -0700 -0700\"</code></p>\n<h2>Conclusion</h2>\n<p>I had a lot of fun building this project. Projects like this keep me thinking about how joyful computing can be (as well as how you can do some really fun things with protocols!). Now that I have the shell of a DNS server and some utilities, I can add new functionalities at any time as I think of them. I don't have any ideas just yet, but I think there's more I can do with my personal website.</p>\n<p>Let me end by extending a big thank you to <a href=\"https://github.com/miekg\">miekg</a> and everyone who worked on the aforementioned DNS library in Go. This library (which also powers dns.toys that I mentioned at the beginning of the article) let me build this project without having to implement a whole DNS server myself.</p>\n<p><a href=\"https://news.indieweb.org/en\" class=\"u-syndication\">Also posted on IndieNews</a>.</p>\n\t\t\n\t\t\t<p>Tagged in <a href=\"https://jamesg.blog/tag/dig/\">dig</a>, <a href=\"https://jamesg.blog/tag/go/\">go</a>, <a href=\"https://jamesg.blog/tag/dns/\">dns</a>.</p>",
      "value" : "TL;DR: I now have my own DNS resolver at @jamesg.blog with some fun utilities. Read the GitHub documentation for a complete reference manual of all queries, and keep reading below for an explanation of the project and how it works.\nIn this week's Homebrew Website Club, someone mentioned dns.toys, a set of playful tools including unit converters that are available by making a DNS query. I found this idea fascinating and I wanted to explore it a bit more. I learned more about how DNS resolution worked last month when reading about traceroute and how it works. I was left with an itch: how can I make something fun over DNS?\nWhen considering what to build, I thought: how about a temperature converter? The idea of a fully-offline, web-powered, free and private temperature conversion tool came up in HWC so unit conversion was top of mind. This project didn't aim to be fully offline or web powered though: DNS is a networking protocol, after all(!).\nTo get started, I first went back to the miekg/dns Go library that I saw a while ago. This library implements, if I recall correctly, most if not all DNS Request for Comments documents. While I understand a bit about the inner workings of DNS, I didn't want this project to be too technical on that side of things. DNS is big. Beyond Tellerrand reminded me that I don't need to try to reinvent the wheel to make something cool. So I decided to worry less about low-level DNS and more about what I wanted to build. Getting started\nBuilding a temperature converter helped me get my foot in the door with this idea. I had a goal in mind, a library that would abstract away a lot of technical details, and a motivating factor: to build a cool DNS utility.\nMy first goal was to build the core application logic. This logic: Initialises a DNS server object. Registers handlers for different resource names (i.e. \"is.it.hwc.day\"). Starts the server.\nI started by writing a handler for temperature conversion, which took some time as I am newer to Go and I haven't worked a lot with floating point arithmatic. I learned about the float32 and float64 functions and I did some manipulation to convert the temperature numbers into strings and the resultant number that would be fed back in the DNS response into a string. I wrote this logic for both Celsius to Fahrenheit and Fahrenheit to Celsius.\nWhile building the temperature converter, I found the \".\" handler matches any query. I use this handler to check for a temperature query. If you query fc100 my application recognises fc as Fahrenheit-to-Celsius and does the conversion on the next number. This involves a bit of string manipulation to remove the fc. Conversely, cf30 converts 30 degrees Celsius to Fahrenheit.\nWhen you run the application, the miekg/dns library creates a server. This server can be run locally and queried.\nHere's an example query made using dig:\ndig @jamesg.blog resource.name\nThis tells dig to query the jamesg.blog DNS server. This server is opened publicly on port 53. But, my application doesn't host directly on port 53. Ports under 1024 are reserved. I would need to give Go special access to directly host applications on port 53. I didn't want to do this so I did some Googling and found an alternative: host the application on a different port internally and forward all traffic from port 53 to this application. I did this using iptables. I also opened up port 53 so you could make DNS queries to my server.\nAll data from my application is sent via TXT records, which allow ASCII-only string contents.\nLocally, when testing, I could not use dig without specifying the port. I did this using this command:\ndig @localhost -p 5000 resource.name\nThis makes a query for the resource resource.name on port 5000. Adding new features\nNext, I started exploring new features. I wondered: what else would be cool to show over DNS? I thought: how about some IndieWeb and personal website features? I decided to host a few TXT records with some information about projects I have worked on, available by querying the \"resume\" resource on my DNS server. Part of me wants to extend this to parse my h-resume and show my full resume over DNS. That is a project for another day. I also made the recent.blog query which gets the title and slug of the blog post I published most recently.\nI wrote three IndieWeb-related features: Check if it is HWC day (Wednesday). Check if it is Newsletter day (Friday). Retrieve the next event from events.indieweb.org, if one is scheduled.\nThe first two functions were simple. My application gets the current day of the week and returns a response depending on whether the current day of the week is equal to Wednesday for HWC day or Friday for newsletter day. The feature that retrieves the next event from the IndieWeb events page took more time to implement. I used the Go microformats parser to parse the events page. Then, I go through all events from top to bottom. The first event that is after the current time is displayed as the next event. I don't order the events page in the application because events.indieweb.org is ordered by the most recent upcoming event first.\nHere's an example of a query to retrieve the next event from the IndieWeb events page:\ndig @jamesg.blog next.indieweb.event\nThis query returns:\nnext.indieweb.event. 0 IN TXT \"IndieWeb Create Day - 2022-09-18 09:00:00 -0700 -0700\" Conclusion\nI had a lot of fun building this project. Projects like this keep me thinking about how joyful computing can be (as well as how you can do some really fun things with protocols!). Now that I have the shell of a DNS server and some utilities, I can add new functionalities at any time as I think of them. I don't have any ideas just yet, but I think there's more I can do with my personal website.\nLet me end by extending a big thank you to miekg and everyone who worked on the aforementioned DNS library in Go. This library (which also powers dns.toys that I mentioned at the beginning of the article) let me build this project without having to implement a whole DNS server myself.\nAlso posted on IndieNews.\nTagged in dig, go, dns.",
      "lang" : "en"
    } ],
    "author" : [ {
      "type" : [ "h-card" ],
      "properties" : {
        "name" : [ "James" ],
        "url" : [ "https://jamesg.blog" ]
      },
      "lang" : "en",
      "value" : "James"
    } ]
  },
  "lang" : "en"
}
