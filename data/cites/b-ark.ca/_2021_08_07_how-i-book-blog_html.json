{
  "type" : [ "h-entry" ],
  "properties" : {
    "name" : [ "How I Book Blog" ],
    "summary" : [ "I used to use Goodreads for tracking/reviewing books I’ve read. Then Amazon bought them and I decided to move all that stuff to my own blog. This is how I did it! #indieweb #ownyourdata" ],
    "category" : [ "#indieweb", "#ownyourdata" ],
    "url" : [ "https://b-ark.ca/2021/08/07/how-i-book-blog.html", "https://b-ark.ca/2021/08/07/how-i-book-blog.html" ],
    "uid" : [ "https://b-ark.ca/2021/08/07/how-i-book-blog.html" ],
    "syndication" : [ "https://twitter.com/brettkosinski/status/1424485087698161677", "https://news.indieweb.org/en/b-ark.ca/2021/08/07/how-i-book-blog.html", "https://news.indieweb.org/en" ],
    "published" : [ "2021-08-07T19:04:12-04:00" ],
    "content" : [ {
      "html" : "<p>So while it turns out I forgot I’d posted about this topic <a href=\"https://b-ark.ca/2020/08/22/my-approach-to-activity-logging.html\">a while ago</a>, it seemed worth revisiting and writing a focused post on how I’m book blogging.</p>\n\n<p>Anyway, I don’t know about you, but I tend to have a remarkably poor memory for the books I’ve read.  After I’ve finished a book or series, it doesn’t take long for the details to get washed out and for my thoughts to blur into vague recollections  of what the book made me think and feel.  It was for this reason that I started using Goodreads.</p>\n\n<p>For me, Goodreads served a few useful functions.  First, it gave me a place to track what I’m reading and, more importantly, what I’ve read.  Second, it gave me a spot to jot down my thoughts about books so that, later, I could go back and read those notes and refresh my memory.</p>\n\n<p>But that meant trapping all of that information in someone else’s silo, and I was never particularly comfortable with that.  And when Amazon went and bought Goodreads, I basically stopped using the service, and as a result, stopped tracking my reading.</p>\n\n<p>When I decided to <a href=\"https://b-ark.ca/2020/01/03/re-inventing-my-blog.html\">reinvent my blog</a>, I undertook the project with a central goal in mind:  to take back control over my own data and content.  To that end, book blogging was a perfect fit for this vision, and so I wanted to describe how I’ve leveraged approaches from the <a href=\"https://indieweb.org/\">IndieWeb</a> to solve this problem and <a href=\"https://indieweb.org/scratch_your_own_itch\">scratch my own itch</a>.</p>\n\n<p>By the way, I want to thank <a href=\"https://www.jvt.me/\">Jamie Tanna</a> and their post on <a href=\"https://www.jvt.me/posts/2021/08/01/books-microformats/\">a Microformats API for Books</a> which reminded me to finally write this post!</p>\n\n<!-- more -->\n\n<h1 id=\"the-problem\">The problem</h1>\n\n<p>For me, book blogging involves tracking a few key events<sup id=\"fnref:1\" role=\"doc-noteref\"><a href=\"https://b-ark.ca/2021/08/07/how-i-book-blog.html#fn:1\" class=\"footnote\" rel=\"footnote\">1</a></sup>:</p>\n\n<ol>\n  <li>Starting a book</li>\n  <li>Finishing a book</li>\n  <li>Recording a review for a book</li>\n</ol>\n\n<p>By itself, this looks pretty straight forward!  For a static site like my own, which is based on <a href=\"https://b-ark.ca/2021/08/07/jekyllrb.com/\">Jekyll</a>, you could create page layouts for each of the event types containing appropriate <a href=\"http://microformats.org\">microformats</a> to mark up the content, and then write posts for each event.  Combined with a <a href=\"https://indieweb.org/Micropub\">micropub</a> endpoint that knows how to deal with <a href=\"https://indieweb.org/read\">read posts</a> and you have a pretty nice solution!</p>\n\n<p>But as Jamie highlighted in their own post on this topic, one of the big challenges with book blogging in general is capturing and storing metadata about books.  In the case of my blog, for each of the aforementioned events I wanted to include a bunch of information about the book, including things like:</p>\n\n<ol>\n  <li>Title and author</li>\n  <li>Series and book number</li>\n  <li>Publication date</li>\n  <li>Cover image</li>\n</ol>\n\n<p>The problem is that having to enter this information in every entry is an enormous pain, particularly for those read/finished posts, which you really want to be able to fire off quickly and easily to minimize the friction of posting.</p>\n\n<p>Jamie’s post outlines a solve for this by providing an API which can be used by IndieWeb sites to pull book metadata during the site build.</p>\n\n<p>However, when I came up with my solution this API didn’t exist!</p>\n\n<p>At the time, in my mind, what I really wanted was something that would make it easy to scrape metadata for books I’m reading from an external source, including pulling cover images from search engines, and then store it locally so that it was really easy to edit that metadata to correct inaccuracies and so forth.  That way I could automate sourcing the raw metadata from elsewhere (obviating the need to hand-enter it), while still being able to manage and curate the information.</p>\n\n<p>And if those external data sources later disappeared, my database wouldn’t, which is a key benefit of owning your data.</p>\n\n<p>With that idea in mind, I ended up taking a very different approach, and it starts with <a href=\"https://calibre-ebook.com/\">Calibre</a>.</p>\n\n<h1 id=\"calibre-as-book-database\">Calibre as book database</h1>\n\n<p>Calibre is an extremely popular ebook management tool that supports tracking and storing digital books and their associated metadata.  Critically, it has a number of very nice attributes that made it an interesting option for me:</p>\n\n<ol>\n  <li>It has a very nice user interface for managing books, both individually and in bulk,</li>\n  <li>It has built in functions for scraping book metadata from popular sources, obviating the need to build that separately,</li>\n  <li>I was already using it!</li>\n</ol>\n\n<p>My thinking went as follows:  what if I could use Calibre to maintain my own ebook database, complete with metadata and covers I’ve pulled from the web?  Then, I could write a Jekyll plugin that, upon build, would look up an ISBN specified in the page front matter, pull the relevant data from Calibre, and then populate the page.</p>\n\n<p>But how do we get the data <em>out</em> of Calibre?</p>\n\n<p>Well, this is the point where I discovered that, to my great surprise, it turns out Calibre has a very rich set of <a href=\"https://manual.calibre-ebook.com/generated/en/cli-index.html\">command-line tools</a><sup id=\"fnref:2\" role=\"doc-noteref\"><a href=\"https://b-ark.ca/2021/08/07/how-i-book-blog.html#fn:2\" class=\"footnote\" rel=\"footnote\">2</a></sup>.  And one of those tools is <a href=\"https://manual.calibre-ebook.com/generated/en/calibredb.html\">calibredb</a>, which is a command-line tool for manipulating and querying data out of the Calibre database and presenting it in both human-readable and machine-readable formats.</p>\n\n<h1 id=\"my-solution\">My solution</h1>\n\n<p>My solution starts with a new Jekyll plugin called <a href=\"https://github.com/fancypantalons/jekyll-library\">jekyll-library</a>.  This plugin functions roughly as follows:</p>\n\n<ol>\n  <li>Find all pages that have an <code class=\"language-plaintext highlighter-rouge\">isbn</code> attribute in the front matter</li>\n  <li>For each matching page, use <code class=\"language-plaintext highlighter-rouge\">calibredb</code> to query book metadata from the Calibre database</li>\n  <li>Extract the book cover image from the Calibre database and store it in a configured target directory</li>\n  <li>Populate a new object called <code class=\"language-plaintext highlighter-rouge\">book</code>, stored with the page data, containing the book metadata and the path to the cover image</li>\n</ol>\n\n<p>Then, in Calibre, in addition to the ISBN, I added a few extra custom ids in the “Ids” block that store URIs for the author, book, and series, which allows me to automatically link to those external references in my posts.</p>\n\n<p>This approach means any page that wants to reference metadata from my Calibre database can just include the <code class=\"language-plaintext highlighter-rouge\">isbn</code> front matter and the plugin does the rest.</p>\n\n<p>After that, it’s up to the user to create page layouts that take advantage of this metadata.  In particular, I’ve created <code class=\"language-plaintext highlighter-rouge\">read</code> and <code class=\"language-plaintext highlighter-rouge\">review</code> post types with associated layouts.  For example, a review post might look like:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>---\nlayout: review\ntitle: \"Review: Some book I read\"\nsummary: \"I'm reviewing this book that I read!\"\nauthor: Brett Kosinski\ndate:   2021-08-01 21:19:56 -0700\ncategory: [ books ]\nisbn: '1234567890123'\n---\nHere's a whole bunch of words about what I thought about this book.\n</code></pre></div></div>\n<p>The plugin and layout then does the rest!</p>\n\n<p>A <code class=\"language-plaintext highlighter-rouge\">read</code> post is even simpler:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>---\nlayout: read\ntitle: Currently reading Some Book\nauthor: Brett Kosinski\ndate: 2020-03-08 15:14:03.929981684 -06:00\nisbn: '1234567890123'\nstatus: reading\ncategory: [ books ]\n---\n</code></pre></div></div>\n\n<p>Status, in this case, could be <code class=\"language-plaintext highlighter-rouge\">reading</code> or <code class=\"language-plaintext highlighter-rouge\">finished</code>.  Easy!</p>\n\n<p>Finally, I updated my micropub endpoint to generate appropriate pages when a <code class=\"language-plaintext highlighter-rouge\">read</code> post is sent in, which works really nicely with <a href=\"https://indiebookclub.biz/\">indiebookclub</a>.</p>\n\n<p>So what about publishing?</p>\n\n<p>Since mine is a static site, my approach to publishing is pretty standard, in that my blog is managed as a git repository, and publishing means doing a <code class=\"language-plaintext highlighter-rouge\">git push</code> to my server.  To that process I added a git pre-push hook that uses rsync to copy my calibre database to my server.  The server-side then has a post-commit hook to trigger the site build.<sup id=\"fnref:3\" role=\"doc-noteref\"><a href=\"https://b-ark.ca/2021/08/07/how-i-book-blog.html#fn:3\" class=\"footnote\" rel=\"footnote\">3</a></sup></p>\n\n<p>And, of course, because these are just another set of posts and I have full control over the infrastructure, they can be syndicated to other silos via <a href=\"https://brid.gy/\">Brid.gy</a>, syndicated to <a href=\"https://micro.blog\">Micro.blog</a> via RSS, and so on.</p>\n\n<p>What I really love about this setup is that, first, I’m not bound to any external source of book metadata.  Because I control my data source, there’s no danger of metadata disappearing, covers being removed, and so forth.  That puts me fully in control of my site.</p>\n\n<p>The other big benefit, for me, is that this lets me leverage something I was already doing with Calibre.  I’ve long used Calibre as a way to store and manage my ebook library, and this approach to book blogging builds on that approach and encourages me to keep my Calibre database clean and up-to-date.  Win win!</p>\n\n<div class=\"footnotes\" role=\"doc-endnotes\">\n  <ol>\n    <li id=\"fn:1\" role=\"doc-endnote\">\n      <p>Note, there’s others you can imagine, here, including progress updates or “plan to read” posts, but I’ve not bothered with either of these at this time, as I don’t find them personally useful. <a href=\"https://b-ark.ca/2021/08/07/how-i-book-blog.html#fnref:1\" class=\"reversefootnote\" role=\"doc-backlink\">↩</a></p>\n    </li>\n    <li id=\"fn:2\" role=\"doc-endnote\">\n      <p>My initial crack at this actually involved directly running <code class=\"language-plaintext highlighter-rouge\">fetch-ebook-metadata</code>, which provides a command-line interface to Calibre’s underlying book metadata scraping infrastructure.  However, it didn’t take me long to discover there was always going to be some human intervention required to clean up and correct the results. <a href=\"https://b-ark.ca/2021/08/07/how-i-book-blog.html#fnref:2\" class=\"reversefootnote\" role=\"doc-backlink\">↩</a></p>\n    </li>\n    <li id=\"fn:3\" role=\"doc-endnote\">\n      <p>Astute readers will note that <code class=\"language-plaintext highlighter-rouge\">read</code> events coming from indiebookclub require that the metadata be in the Calibre database, and the database be sync’d to the server, before the event can be pushed.  This is definitely a little bit cumbersome, but not so much that it’s proven to be an issue. <a href=\"https://b-ark.ca/2021/08/07/how-i-book-blog.html#fnref:3\" class=\"reversefootnote\" role=\"doc-backlink\">↩</a></p>\n    </li>\n  </ol>\n</div>",
      "value" : "So while it turns out I forgot I’d posted about this topic a while ago, it seemed worth revisiting and writing a focused post on how I’m book blogging.\nAnyway, I don’t know about you, but I tend to have a remarkably poor memory for the books I’ve read. After I’ve finished a book or series, it doesn’t take long for the details to get washed out and for my thoughts to blur into vague recollections of what the book made me think and feel. It was for this reason that I started using Goodreads.\nFor me, Goodreads served a few useful functions. First, it gave me a place to track what I’m reading and, more importantly, what I’ve read. Second, it gave me a spot to jot down my thoughts about books so that, later, I could go back and read those notes and refresh my memory.\nBut that meant trapping all of that information in someone else’s silo, and I was never particularly comfortable with that. And when Amazon went and bought Goodreads, I basically stopped using the service, and as a result, stopped tracking my reading.\nWhen I decided to reinvent my blog, I undertook the project with a central goal in mind: to take back control over my own data and content. To that end, book blogging was a perfect fit for this vision, and so I wanted to describe how I’ve leveraged approaches from the IndieWeb to solve this problem and scratch my own itch.\nBy the way, I want to thank Jamie Tanna and their post on a Microformats API for Books which reminded me to finally write this post! The problem\nFor me, book blogging involves tracking a few key events1: Starting a book Finishing a book Recording a review for a book\nBy itself, this looks pretty straight forward! For a static site like my own, which is based on Jekyll, you could create page layouts for each of the event types containing appropriate microformats to mark up the content, and then write posts for each event. Combined with a micropub endpoint that knows how to deal with read posts and you have a pretty nice solution!\nBut as Jamie highlighted in their own post on this topic, one of the big challenges with book blogging in general is capturing and storing metadata about books. In the case of my blog, for each of the aforementioned events I wanted to include a bunch of information about the book, including things like: Title and author Series and book number Publication date Cover image\nThe problem is that having to enter this information in every entry is an enormous pain, particularly for those read/finished posts, which you really want to be able to fire off quickly and easily to minimize the friction of posting.\nJamie’s post outlines a solve for this by providing an API which can be used by IndieWeb sites to pull book metadata during the site build.\nHowever, when I came up with my solution this API didn’t exist!\nAt the time, in my mind, what I really wanted was something that would make it easy to scrape metadata for books I’m reading from an external source, including pulling cover images from search engines, and then store it locally so that it was really easy to edit that metadata to correct inaccuracies and so forth. That way I could automate sourcing the raw metadata from elsewhere (obviating the need to hand-enter it), while still being able to manage and curate the information.\nAnd if those external data sources later disappeared, my database wouldn’t, which is a key benefit of owning your data.\nWith that idea in mind, I ended up taking a very different approach, and it starts with Calibre. Calibre as book database\nCalibre is an extremely popular ebook management tool that supports tracking and storing digital books and their associated metadata. Critically, it has a number of very nice attributes that made it an interesting option for me: It has a very nice user interface for managing books, both individually and in bulk, It has built in functions for scraping book metadata from popular sources, obviating the need to build that separately, I was already using it!\nMy thinking went as follows: what if I could use Calibre to maintain my own ebook database, complete with metadata and covers I’ve pulled from the web? Then, I could write a Jekyll plugin that, upon build, would look up an ISBN specified in the page front matter, pull the relevant data from Calibre, and then populate the page.\nBut how do we get the data out of Calibre?\nWell, this is the point where I discovered that, to my great surprise, it turns out Calibre has a very rich set of command-line tools2. And one of those tools is calibredb, which is a command-line tool for manipulating and querying data out of the Calibre database and presenting it in both human-readable and machine-readable formats. My solution\nMy solution starts with a new Jekyll plugin called jekyll-library. This plugin functions roughly as follows: Find all pages that have an isbn attribute in the front matter For each matching page, use calibredb to query book metadata from the Calibre database Extract the book cover image from the Calibre database and store it in a configured target directory Populate a new object called book, stored with the page data, containing the book metadata and the path to the cover image\nThen, in Calibre, in addition to the ISBN, I added a few extra custom ids in the “Ids” block that store URIs for the author, book, and series, which allows me to automatically link to those external references in my posts.\nThis approach means any page that wants to reference metadata from my Calibre database can just include the isbn front matter and the plugin does the rest.\nAfter that, it’s up to the user to create page layouts that take advantage of this metadata. In particular, I’ve created read and review post types with associated layouts. For example, a review post might look like: --- layout: review title: \"Review: Some book I read\" summary: \"I'm reviewing this book that I read!\" author: Brett Kosinski date: 2021-08-01 21:19:56 -0700 category: [ books ] isbn: '1234567890123' --- Here's a whole bunch of words about what I thought about this book.\nThe plugin and layout then does the rest!\nA read post is even simpler: --- layout: read title: Currently reading Some Book author: Brett Kosinski date: 2020-03-08 15:14:03.929981684 -06:00 isbn: '1234567890123' status: reading category: [ books ] ---\nStatus, in this case, could be reading or finished. Easy!\nFinally, I updated my micropub endpoint to generate appropriate pages when a read post is sent in, which works really nicely with indiebookclub.\nSo what about publishing?\nSince mine is a static site, my approach to publishing is pretty standard, in that my blog is managed as a git repository, and publishing means doing a git push to my server. To that process I added a git pre-push hook that uses rsync to copy my calibre database to my server. The server-side then has a post-commit hook to trigger the site build.3\nAnd, of course, because these are just another set of posts and I have full control over the infrastructure, they can be syndicated to other silos via Brid.gy, syndicated to Micro.blog via RSS, and so on.\nWhat I really love about this setup is that, first, I’m not bound to any external source of book metadata. Because I control my data source, there’s no danger of metadata disappearing, covers being removed, and so forth. That puts me fully in control of my site.\nThe other big benefit, for me, is that this lets me leverage something I was already doing with Calibre. I’ve long used Calibre as a way to store and manage my ebook library, and this approach to book blogging builds on that approach and encourages me to keep my Calibre database clean and up-to-date. Win win!\nNote, there’s others you can imagine, here, including progress updates or “plan to read” posts, but I’ve not bothered with either of these at this time, as I don’t find them personally useful. ↩\nMy initial crack at this actually involved directly running fetch-ebook-metadata, which provides a command-line interface to Calibre’s underlying book metadata scraping infrastructure. However, it didn’t take me long to discover there was always going to be some human intervention required to clean up and correct the results. ↩\nAstute readers will note that read events coming from indiebookclub require that the metadata be in the Calibre database, and the database be sync’d to the server, before the event can be pushed. This is definitely a little bit cumbersome, but not so much that it’s proven to be an issue. ↩",
      "lang" : "en"
    } ],
    "author" : [ {
      "type" : [ "h-card" ],
      "properties" : {
        "name" : [ "Brett Kosinski" ],
        "photo" : [ "https://b-ark.ca/assets/images/profile_photo.jpg" ],
        "url" : [ "https://b-ark.ca" ],
        "uid" : [ "https://b-ark.ca" ]
      },
      "lang" : "en",
      "value" : "Brett Kosinski"
    } ]
  },
  "lang" : "en",
  "children" : [ {
    "type" : [ "h-cite" ],
    "properties" : {
      "content" : [ "Permission.io favorited a tweet https://blog.b-ark.ca/2021/08/07/how-i-book-blog.html" ],
      "published" : [ "2021-08-13T11:39:09+00:00" ],
      "author" : [ {
        "type" : [ "h-card" ],
        "properties" : {
          "name" : [ "Permission.io" ],
          "url" : [ "https://twitter.com/PermissionIO" ],
          "photo" : [ {
            "value" : "https://webmention.io/avatar/pbs.twimg.com/49aaf6a7724e4deb92196ab632ad7634cdcd36a66f81a9618c54b39532372f9c.jpg",
            "alt" : ""
          } ]
        },
        "lang" : "en",
        "value" : "Permission.io"
      } ]
    },
    "lang" : "en"
  } ]
}
