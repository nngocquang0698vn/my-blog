{
  "type" : [ "h-entry" ],
  "properties" : {
    "name" : [ "Transparently running binaries from any architecture in Linux with QEMU and binfmt_misc" ],
    "category" : [ "arm", "kernel", "linux", "qemu" ],
    "url" : [ "https://ownyourbits.com/2018/06/13/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt_misc/", "https://ownyourbits.com/2018/06/13/transparently-running-binaries-from-any-architecture-in-linux-with-qemu-and-binfmt_misc/" ],
    "published" : [ "2018-06-13T10:14:36+00:00" ],
    "updated" : [ "2018-06-14T06:55:26+00:00" ],
    "content" : [ {
      "html" : "<p>&#xA0;</p>\n<p>&#xA0;</p>\n<p>What? you can do that in Linux? It turns out you can!</p>\n<p>First, let&#x2019;s see it in action. Here I retrieve a binary from my Raspberry Pi which is an ARM binary and execute it in my <em>x86_64</em> machine transparently.</p>\n<p><img loading=\"lazy\" class=\"aligncenter size-full wp-image-2684\" src=\"https://ownyourbits.com/wp-content/uploads/2018/05/arm-echo.gif\" alt=\"\" width=\"820\" height=\"548\"></p>\n<p>If you try to do this&#x2026; it won&#x2019;t work right away.</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ ./echo\nzsh: exec format error: ./echo</pre>\n<p>First we have a couple things to set up. We will be using <a href=\"http://qemu.org\">QEMU</a> in a slightly unconventional way in a combination with a kernel feature called <em>binfmt_misc</em>.</p>\n<p>&#xA0;</p>\n<h4>QEMU user mode</h4>\n<p>&#xA0;</p>\n<p>Obviously our CPU is not able to run foreign machine code instructions. We said we would be using QEMU, but in a slightly unconventional way.</p>\n<p>We all know QEMU as a virtual machine, where we load a virtual (fake) hard drive with an operating system and we setup fake hardware to interface with it: a fake CPU, fake keyboard, fake network adapter and so on. This look like this</p>\n<p><img loading=\"lazy\" class=\"aligncenter wp-image-2837\" src=\"https://ownyourbits.com/wp-content/uploads/2018/06/emul-qemu.png\" alt=\"\" width=\"302\" height=\"260\" srcset=\"\" sizes=\"(max-width: 302px) 100vw, 302px\"></p>\n<p>But there is also another <em>mode</em> of use in QEMU, called <em>user emulation</em>.</p>\n<p>When we write a program, we interact with the system through <a href=\"https://en.wikipedia.org/wiki/System_call\"><em>system calls</em></a>. We need to do this in order to interact with the keyboard, terminal, screen, filesystem and so on. This means that when we execute a program, the code that we write is executed in <em>user space</em>, and then the kernel does the interacting with the system part for us. We just request things from the kernel such as writing to a file.</p>\n<p>In QEMU <em>system emulation</em> this looks like this</p>\n<p><img loading=\"lazy\" class=\"aligncenter wp-image-2836\" src=\"https://ownyourbits.com/wp-content/uploads/2018/06/qemu-system.png\" alt=\"\" width=\"304\" height=\"261\" srcset=\"\" sizes=\"(max-width: 304px) 100vw, 304px\"></p>\n<p>In <em>user mode</em>, QEMU doesn&#x2019;t emulate all the hardware, only the CPU.&#xA0; It executes foreign code in the emulated CPU, and then it captures the syscalls and&#xA0; forwards them to the host kernel. This way, we are interfacing the native kernel in the same way as any native piece of software. This looks like this</p>\n<p><img loading=\"lazy\" class=\"aligncenter wp-image-2835\" src=\"https://ownyourbits.com/wp-content/uploads/2018/06/qemu-user.png\" alt=\"\" width=\"298\" height=\"256\" srcset=\"\" sizes=\"(max-width: 298px) 100vw, 298px\"></p>\n<p>This has many benefits, because we are not emulating all the hardware, which is slow, and also we are not emulating the kernel which is a decent part of the computation that takes place. Actually we don&#x2019;t even <em>need</em> a kernel. We can understand now why this runs much faster than full system emulation.</p>\n<p>As an example, let&#x2019;s crosscompile a static ARM binary</p>\n<pre class=\"toolbar:1 lang:c decode:true\" title=\"hello.c\">#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv) {\n    printf(\"hello world\\n\");\n    return 0;\n}</pre>\n<p>we need to install the toolchain to crosscompile from <em>x86</em> to <em>armhf</em>, for instance</p>\n<pre class=\"lang:default highlight:0 decode:true \"># apt-get install gcc-arm-linux-gnueabihf</pre>\n<p>, or in Arch Linux</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ pacaur -S aur/arm-linux-gnueabihf-gcc</pre>\n<p>Then we generate the binary</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static\n$ file hello_arm_static\nhello_arm_static: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=69ff53a55d64975f87b9ea3543d26bcbae31de9f, with debug_info, not stripped</pre>\n<p>Now we can run it with <em>qemu-arm</em>. We need to install the package <em>qemu-user</em></p>\n<pre class=\"lang:default highlight:0 decode:true\"># apt-get install qemu-user</pre>\n<p>, and now we can run</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ qemu-arm hello_arm_static\nhello world</pre>\n<p>This isn&#x2019;t yet very useful because most programs are <em>dynamically linked</em>. We still have some work to do.</p>\n<p>&#xA0;</p>\n<h4>Running ARM executables transparently</h4>\n<p>&#xA0;</p>\n<p>Recall from the <a href=\"https://ownyourbits.com/2018/05/23/the-real-power-of-linux-executables/\">last post</a> on Linux executables what happens when we execute a file and how we can use <em>binfmt_misc</em> to set up our own interpreters. Now we have all the pieces and we want to put them together. We need to setup <em>binfmt_misc</em> in order to use QEMU user mode as an interpreter for our <em>binary format</em>.</p>\n<p>We can do it ourselves manually, or install the<em> qemu-user-binfmt</em> package, normally installed automatically with<em> qemu-user</em>. We end up with the<em> binfmt_misc</em> entries</p>\n<pre class=\"lang:default highlight:0 decode:true \">ls -l /proc/sys/fs/binfmt_misc\ntotal 0\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-aarch64\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-alpha\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-arm\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-armeb\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-cris\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-m68k\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-microblaze\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-mips\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-mipsel\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-ppc\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-ppc64\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-ppc64abi32\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-s390x\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sh4\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sh4eb\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sparc\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sparc32plus\n-rw-r--r-- 1 root root 0 Jun  7 11:36 qemu-sparc64\n--w------- 1 root root 0 Jun  7 11:36 register\n-rw-r--r-- 1 root root 0 Jun  7 11:36 status</pre>\n<p>Now we can substitute</p>\n<pre class=\"lang:default highlight:0 decode:true \">$ qemu_arm hello_arm_static\nhello world</pre>\n<p>for</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ ./hello_arm_static\nhello world</pre>\n<p>, because we have an active entry in <em>binfmt_misc</em></p>\n<pre class=\"lang:default highlight:0 decode:true\">$ cat /proc/sys/fs/binfmt_misc/qemu-arm\nenabled\ninterpreter /usr/bin/qemu-arm-static\nflags: OC\noffset 0\nmagic 7f454c4601010100000000000000000002002800\nmask ffffffffffffff00fffffffffffffffffeffffff</pre>\n<p>The kernel recognizes the ARM <a href=\"http://man7.org/linux/man-pages/man5/elf.5.html\">ELF magic</a>, and uses the interpreter <span class=\"lang:default highlight:0 decode:true crayon-inline\">/usr/bin/qemu-arm-static</span> , which is the correct QEMU binary for the architecture.&#xA0;<span class=\"lang:default highlight:0 decode:true crayon-inline\">0x7F &#x2018;ELF&#x2019;</span>&#xA0; in hexadecimal is <span class=\"lang:default highlight:0 decode:true crayon-inline\">7f 45 4c 46</span>, so we can see how the magic and the mask work together, considering the structure of the ELF header</p>\n<pre class=\"lang:default mark:2,4 highlight:0 decode:true\">typedef struct {\n    unsigned char e_ident[EI_NIDENT];   /* 0x7F 'ELF' four byte ELF magic for any architecture */\n    uint16_t e_type;\n    uint16_t e_machine;                 /* architecture code, 40=0x28 in the case of ARM */\n    uint32_t e_version;\n    ElfN_Addr e_entry;\n    ElfN_Off e_phoff;\n    ElfN_Off e_shoff;\n    uint32_t e_flags;\n    uint16_t e_ehsize;\n    uint16_t e_phentsize;\n    uint16_t e_phnum;\n    uint16_t e_shentsize;\n    uint16_t e_shnum;\n    uint16_t e_shstrndx;\n} ElfN_Ehdr;</pre>\n<p>At the end of the day, we want our code to tell the kernel to print <em>hello world. </em>Let&#x2019;s compare the kernel interactions of the real</p>\n<pre class=\"lang:default highlight:0 decode:true \">$ strace ./hello_static 2&gt;&amp;1 | grep -e execve -e readlink -e write\nexecve(\"./hello_static\", [\"./hello_static\"], 0x7ffd3d83b2b0 /* 41 vars */) = 0\nreadlink(\"/proc/self/exe\", \"/home/nacho/srctest/hello_static\", 4096) = 32\nwrite(1, \"hello world\\n\", 12hello world</pre>\n<p>and the emulated code</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ strace ./hello_arm_static 2&gt;&amp;1 | grep -e execve -e readlink -e write\nexecve(\"./hello_arm_static\", [\"./hello_arm_static\"], 0x7ffd4b19b5c0 /* 41 vars */) = 0\nreadlink(\"/proc/self/exe\", \"/usr/bin/qemu-arm-static\", 4096) = 24\nwrite(1, \"hello world\\n\", 12hello world</pre>\n<p>The <em>execve()</em> syscall is the same, and the <em>write()&#xA0; </em>call too so we get the same behaviour. We can also see that a read to <em>/proc/self/exe</em> reveals that the binary being run natively is in fact <em>qemu-arm-static</em>, the interpreter.<em><br>\n</em></p>\n<p>Again, most of the work is being done natively by the kernel, so this actually runs much faster than in QEMU full emulation because the part of the kernel execution would need to be emulated too, as well as the virtual hardware. It is also much easier to setup.<em><br>\n</em></p>\n<p>This is still not <em>that</em> useful yet, because very few programs are statically linked. Let&#x2019;s create <em>x86</em> and <em>amrhf</em> versions of <em>hello.c</em></p>\n<pre class=\"lang:default highlight:0 decode:true\">$ gcc hello.c -o hello\n$ gcc hello.c -o hello_static -static\n$ arm-linux-gnueabihf-gcc hello.c -o hello_arm\n$ arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static</pre>\n<p>ARM binaries take much more space, because being a RISC architecture it has a smaller instruction set and so it needs more machine code to perform many common operations. Code density can be improved by using the <a href=\"https://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb\">THUMB instruction set</a>.</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ dutree\n[ crosshello 4.64 MiB ]\n&#x251C;&#x2500; hello_arm_static  &#x2502;          &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2502;  84%      3.91 MiB\n&#x251C;&#x2500; hello_static      &#x2502;                                                   &#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2588;&#x2502;  15%    724.89 KiB\n&#x251C;&#x2500; hello_arm         &#x2502;                                                         &#x2502;   0%     15.62 KiB\n&#x251C;&#x2500; hello             &#x2502;                                                         &#x2502;   0%      8.16 KiB\n&#x2514;&#x2500; hello.c           &#x2502;                                                         &#x2502;   0%          97 B</pre>\n<p>Let&#x2019;s try this</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ ./hello_arm\n/lib/ld-linux-armhf.so.3: No such file or directory</pre>\n<p>Dynamically linked executables provide the path of the runtime linker ( a.k.a ELF interpreter ) hardcoded at compile time.</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ file hello_arm\nhello_arm: ELF 32-bit LSB pie executable ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=2be332452ae4987fa763b6e75c359e08793572aa, with debug_info, not stripped\n\n$ file hello\nhello: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d11d6a23094a98009919746b13a1c064450aa944, not stripped\n</pre>\n<p>So the code fails because it cannot find the linker that it requires <em>/lib/ld-linux-armhf.so.3</em>. This normally comes with the cross-toolchain.</p>\n<p>We&#xA0;<em>could </em>be tempted to do something really dirty like</p>\n<pre class=\"lang:default highlight:0 decode:true\"># ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3</pre>\n<p>We would need to do this not only for <em>ld-linux-armhf.so</em>, but also for <em>libc.so </em> and everything else our binary might need, and we don&#x2019;t want to have a mix of libraries of different architectures in the same place, right?</p>\n<p>We can tell QEMU where to look for the linker and libraries with</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ qemu-arm -L /usr/arm-linux-gnueabihf hello_arm\nhello world</pre>\n<p>but we want <em>transparent</em> execution, so we can add this to <em>.bashrc </em>or <em>.zshrc</em></p>\n<pre class=\"lang:default highlight:0 decode:true\">export QEMU_LD_PREFIX=/usr/arm-linux-gnueabihf</pre>\n<p>, or configure it system wide at <em>/etc/qemu-binfmt.conf</em></p>\n<pre class=\"toolbar:1 lang:default highlight:0 decode:true \" title=\"/etc/qemu-binfmt.conf\">EXTRA_OPTS=\"-L /usr/arm-linux-gnueabihf\"</pre>\n<p>Now it works transparently!</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ ./hello_arm\nhello world</pre>\n<p>This is still not <em>that</em> useful. The reason is that we now need to have a copy of all the ARM libraries required by our ARM binaries.</p>\n<p>Our example works because everything <em>hello.c</em> needs is so basic that comes with the toolchain.</p>\n<pre class=\"lang:default highlight:0 decode:true \">$ ldd hello\nlinux-vdso.so.1 (0x00007ffd71ab5000)\nlibc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f536fe48000)\n/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5370406000)</pre>\n<p>The situation is not too bad in Debian, where you can install libraries from other architectures, for instance</p>\n<pre class=\"lang:default highlight:0 decode:true\"># apt-get install libstdc++6:armhf</pre>\n<p>&#xA0;</p>\n<h4>Emulating full ARM rootfs</h4>\n<p>&#xA0;</p>\n<p>Most often in real situations we need to work in the final system where the binary is supposed to run. It makes more sense to have the whole ARM environment with its ARM libraries and all. Enter <a href=\"https://en.wikipedia.org/wiki/Chroot\">chroot</a>.</p>\n<p>chroot, for <em>change root</em> is a <a href=\"https://linux.die.net/man/2/chroot\">system call</a> and corresponding command wrapper that changes the root directory location of a process and its children. Given a directory with a different root filesystem, we can execute anything in it so that their <em>view</em> of the filesystem has been moved to the new root directory. For this reason it is often called a <em>chroot jail</em>. This is the predecessor of filesystem namespaces, a key component that makes containers possible.</p>\n<p>As an example, let&#x2019;s execute <em>echo</em> inside an x86 jail. I have prepared a whole Debian filesystem in <span class=\"lang:default highlight:0 decode:true crayon-inline \">new_root_folder</span>&#xA0;.</p>\n<pre class=\"lang:default highlight:0 decode:true\"># chroot new_root_folder /bin/echo \"hello world\"\nhello world</pre>\n<p>This <em>echo</em>, or whatever&#xA0; binary we run does not see anything outside of the jail. It is impossible for instance to remove or read a file outside of the new root folder.</p>\n<p>We can get an existing ARM rootfs to work with, or we can generate one. In Debian we can use <a href=\"https://wiki.debian.org/Debootstrap\"><em>debootstrap</em></a> with the&#xA0;<span class=\"lang:default highlight:0 decode:true crayon-inline \">&#x2013;arch</span>&#xA0; switch to generate a Stretch ARM rootfs.</p>\n<pre class=\"lang:default highlight:0 decode:true\">$ debootstrap --arch=armhf stretch new_root_folder</pre>\n<p>What we want to do now is to use chroot to make the binaries inside the jail view the filesystem just like they expect it. By using chroot we already have <em>/etc</em>, <em>/bin</em> and all the regular folders in place. Next, we need to add the virtual filesystems</p>\n<pre class=\"lang:default highlight:0 decode:true\"># mount -t proc proc     new_root_folder/proc/\n# mount -t sysfs sys     new_root_folder/sys/\n# mount -o bind /dev     new_root_folder/dev/\n# mount -o bind /dev/pts new_root_folder/dev/pts</pre>\n<p>Finally, we will copy the <em>qemu-user-static</em> binary inside the ARM filesystem.</p>\n<pre class=\"lang:default highlight:0 decode:true \"># cp /usr/bin/qemu-arm-static new_root_folder/usr/bin</pre>\n<p>This little intruder will be the only x86 binary in an ARM filesystem, he&#x2019;s surrounded!</p>\n<p>We have everything in place! What will happen when we try to execute some ARM executable from the jail?</p>\n<ul>\n<li>The chroot command will call <em>execve()</em> on the ARM binary</li>\n<li>The ARM binary will be handled by the <em>binfmt_misc</em> binary handler, according to its configured ARM ELF magic.</li>\n<li>The entry in <em>binfmt_misc</em> instructs the kernel to use <em>/usr/bin/qemu-arm-static</em> as an interpreter, that is why we had to copy it inside the jail. Remember that by chroot magic /usr/bin is really inside <em>new_root_folder</em>.</li>\n<li><em>qemu-arm-static</em> will interpret the ARM binary in user mode. We are using the <em>static</em> version of qemu-arm because we need the interpreter to be standalone, as it is the only x86 binary in the jail and will not have access to any x86 libraries.</li>\n<li>Any ARM library that is expected by the programs inside the jail will be there, as provided by the ARM rootfs.</li>\n</ul>\n<p>Let&#x2019;s see all this in action, opening a <em>bash</em> shell in a Raspbian rootfs</p>\n<p><img loading=\"lazy\" class=\"aligncenter size-full wp-image-2832\" src=\"https://ownyourbits.com/wp-content/uploads/2018/06/qemu-chroot2.gif\" alt=\"\" width=\"1076\" height=\"650\"></p>\n<p>I had to configure the PATH variable to match the one Raspbian expects. Naturally, our original environment from <em>zsh</em> will be inherited by <em>chroot</em> and <em>arm-bash</em>. We have talked about full system <a href=\"https://ownyourbits.com/2017/02/06/raspbian-on-qemu-with-network-access/\">QEMU Raspbian emulation</a> before, and this runs so much faster.</p>\n<p>Things will work as long as the ARM binaries see what they expect to see. Binaries can <em>execve()</em> other executables and everything will mostly work perfectly well. An exception would be programs that use exotic system calls that QEMU user mode still has not implemented yet, for instance for using the pseudo random generator. As QEMU user mode becomes more mature, it is getting more strange to see this happen and normally libraries have fallback options for these situations anyway. In those cases you will see something like</p>\n<pre class=\"lang:default highlight:0 decode:true\">qemu: Unsupported syscall: 384</pre>\n<p>Remember that we are still using our host kernel, so we can use networking, install packages with <em>apt</em> and all the rest. This is really useful for things like</p>\n<ul>\n<li>Manipulating rootfs images for other architectures transparently from our x86 workstation.</li>\n<li>Compiling ARM binaries more easily. Cross-compiling is hard because you need to isolate the libraries and tools that the cross-compiling environment needs with the ones from your workstation. One way of saving some headaches is to emulate native compiling instead of cross compiling. You host can then help <em>natively </em>by setting up a <a href=\"https://en.wikipedia.org/wiki/Distcc\"><em>distcc</em></a> system between jail and host.</li>\n</ul>",
      "value" : " \n \nWhat? you can do that in Linux? It turns out you can!\nFirst, let’s see it in action. Here I retrieve a binary from my Raspberry Pi which is an ARM binary and execute it in my x86_64 machine transparently.\n\nIf you try to do this… it won’t work right away. $ ./echo zsh: exec format error: ./echo\nFirst we have a couple things to set up. We will be using QEMU in a slightly unconventional way in a combination with a kernel feature called binfmt_misc.\n  QEMU user mode\n \nObviously our CPU is not able to run foreign machine code instructions. We said we would be using QEMU, but in a slightly unconventional way.\nWe all know QEMU as a virtual machine, where we load a virtual (fake) hard drive with an operating system and we setup fake hardware to interface with it: a fake CPU, fake keyboard, fake network adapter and so on. This look like this\n\nBut there is also another mode of use in QEMU, called user emulation.\nWhen we write a program, we interact with the system through system calls. We need to do this in order to interact with the keyboard, terminal, screen, filesystem and so on. This means that when we execute a program, the code that we write is executed in user space, and then the kernel does the interacting with the system part for us. We just request things from the kernel such as writing to a file.\nIn QEMU system emulation this looks like this\n\nIn user mode, QEMU doesn’t emulate all the hardware, only the CPU.  It executes foreign code in the emulated CPU, and then it captures the syscalls and  forwards them to the host kernel. This way, we are interfacing the native kernel in the same way as any native piece of software. This looks like this\n\nThis has many benefits, because we are not emulating all the hardware, which is slow, and also we are not emulating the kernel which is a decent part of the computation that takes place. Actually we don’t even need a kernel. We can understand now why this runs much faster than full system emulation.\nAs an example, let’s crosscompile a static ARM binary #include <stdio.h> int main(int argc, char** argv) { printf(\"hello world\\n\"); return 0; }\nwe need to install the toolchain to crosscompile from x86 to armhf, for instance # apt-get install gcc-arm-linux-gnueabihf\n, or in Arch Linux $ pacaur -S aur/arm-linux-gnueabihf-gcc\nThen we generate the binary $ arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static $ file hello_arm_static hello_arm_static: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=69ff53a55d64975f87b9ea3543d26bcbae31de9f, with debug_info, not stripped\nNow we can run it with qemu-arm. We need to install the package qemu-user # apt-get install qemu-user\n, and now we can run $ qemu-arm hello_arm_static hello world\nThis isn’t yet very useful because most programs are dynamically linked. We still have some work to do.\n  Running ARM executables transparently\n \nRecall from the last post on Linux executables what happens when we execute a file and how we can use binfmt_misc to set up our own interpreters. Now we have all the pieces and we want to put them together. We need to setup binfmt_misc in order to use QEMU user mode as an interpreter for our binary format.\nWe can do it ourselves manually, or install the qemu-user-binfmt package, normally installed automatically with qemu-user. We end up with the binfmt_misc entries ls -l /proc/sys/fs/binfmt_misc total 0 -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-aarch64 -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-alpha -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-arm -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-armeb -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-cris -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-m68k -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-microblaze -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-mips -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-mipsel -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-ppc -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-ppc64 -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-ppc64abi32 -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-s390x -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-sh4 -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-sh4eb -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-sparc -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-sparc32plus -rw-r--r-- 1 root root 0 Jun 7 11:36 qemu-sparc64 --w------- 1 root root 0 Jun 7 11:36 register -rw-r--r-- 1 root root 0 Jun 7 11:36 status\nNow we can substitute $ qemu_arm hello_arm_static hello world\nfor $ ./hello_arm_static hello world\n, because we have an active entry in binfmt_misc $ cat /proc/sys/fs/binfmt_misc/qemu-arm enabled interpreter /usr/bin/qemu-arm-static flags: OC offset 0 magic 7f454c4601010100000000000000000002002800 mask ffffffffffffff00fffffffffffffffffeffffff\nThe kernel recognizes the ARM ELF magic, and uses the interpreter /usr/bin/qemu-arm-static , which is the correct QEMU binary for the architecture. 0x7F ‘ELF’  in hexadecimal is 7f 45 4c 46, so we can see how the magic and the mask work together, considering the structure of the ELF header typedef struct { unsigned char e_ident[EI_NIDENT]; /* 0x7F 'ELF' four byte ELF magic for any architecture */ uint16_t e_type; uint16_t e_machine; /* architecture code, 40=0x28 in the case of ARM */ uint32_t e_version; ElfN_Addr e_entry; ElfN_Off e_phoff; ElfN_Off e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx; } ElfN_Ehdr;\nAt the end of the day, we want our code to tell the kernel to print hello world. Let’s compare the kernel interactions of the real $ strace ./hello_static 2>&1 | grep -e execve -e readlink -e write execve(\"./hello_static\", [\"./hello_static\"], 0x7ffd3d83b2b0 /* 41 vars */) = 0 readlink(\"/proc/self/exe\", \"/home/nacho/srctest/hello_static\", 4096) = 32 write(1, \"hello world\\n\", 12hello world\nand the emulated code $ strace ./hello_arm_static 2>&1 | grep -e execve -e readlink -e write execve(\"./hello_arm_static\", [\"./hello_arm_static\"], 0x7ffd4b19b5c0 /* 41 vars */) = 0 readlink(\"/proc/self/exe\", \"/usr/bin/qemu-arm-static\", 4096) = 24 write(1, \"hello world\\n\", 12hello world\nThe execve() syscall is the same, and the write()  call too so we get the same behaviour. We can also see that a read to /proc/self/exe reveals that the binary being run natively is in fact qemu-arm-static, the interpreter.\n\nAgain, most of the work is being done natively by the kernel, so this actually runs much faster than in QEMU full emulation because the part of the kernel execution would need to be emulated too, as well as the virtual hardware. It is also much easier to setup.\n\nThis is still not that useful yet, because very few programs are statically linked. Let’s create x86 and amrhf versions of hello.c $ gcc hello.c -o hello $ gcc hello.c -o hello_static -static $ arm-linux-gnueabihf-gcc hello.c -o hello_arm $ arm-linux-gnueabihf-gcc hello.c -o hello_arm_static -static\nARM binaries take much more space, because being a RISC architecture it has a smaller instruction set and so it needs more machine code to perform many common operations. Code density can be improved by using the THUMB instruction set. $ dutree [ crosshello 4.64 MiB ] ├─ hello_arm_static │ ███████████████████████████████████████████████│ 84% 3.91 MiB ├─ hello_static │ ██████│ 15% 724.89 KiB ├─ hello_arm │ │ 0% 15.62 KiB ├─ hello │ │ 0% 8.16 KiB └─ hello.c │ │ 0% 97 B\nLet’s try this $ ./hello_arm /lib/ld-linux-armhf.so.3: No such file or directory\nDynamically linked executables provide the path of the runtime linker ( a.k.a ELF interpreter ) hardcoded at compile time. $ file hello_arm hello_arm: ELF 32-bit LSB pie executable ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=2be332452ae4987fa763b6e75c359e08793572aa, with debug_info, not stripped $ file hello hello: ELF 64-bit LSB pie executable x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=d11d6a23094a98009919746b13a1c064450aa944, not stripped\nSo the code fails because it cannot find the linker that it requires /lib/ld-linux-armhf.so.3. This normally comes with the cross-toolchain.\nWe could be tempted to do something really dirty like # ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3\nWe would need to do this not only for ld-linux-armhf.so, but also for libc.so and everything else our binary might need, and we don’t want to have a mix of libraries of different architectures in the same place, right?\nWe can tell QEMU where to look for the linker and libraries with $ qemu-arm -L /usr/arm-linux-gnueabihf hello_arm hello world\nbut we want transparent execution, so we can add this to .bashrc or .zshrc export QEMU_LD_PREFIX=/usr/arm-linux-gnueabihf\n, or configure it system wide at /etc/qemu-binfmt.conf EXTRA_OPTS=\"-L /usr/arm-linux-gnueabihf\"\nNow it works transparently! $ ./hello_arm hello world\nThis is still not that useful. The reason is that we now need to have a copy of all the ARM libraries required by our ARM binaries.\nOur example works because everything hello.c needs is so basic that comes with the toolchain. $ ldd hello linux-vdso.so.1 (0x00007ffd71ab5000) libc.so.6 => /usr/lib/libc.so.6 (0x00007f536fe48000) /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007f5370406000)\nThe situation is not too bad in Debian, where you can install libraries from other architectures, for instance # apt-get install libstdc++6:armhf\n  Emulating full ARM rootfs\n \nMost often in real situations we need to work in the final system where the binary is supposed to run. It makes more sense to have the whole ARM environment with its ARM libraries and all. Enter chroot.\nchroot, for change root is a system call and corresponding command wrapper that changes the root directory location of a process and its children. Given a directory with a different root filesystem, we can execute anything in it so that their view of the filesystem has been moved to the new root directory. For this reason it is often called a chroot jail. This is the predecessor of filesystem namespaces, a key component that makes containers possible.\nAs an example, let’s execute echo inside an x86 jail. I have prepared a whole Debian filesystem in new_root_folder . # chroot new_root_folder /bin/echo \"hello world\" hello world\nThis echo, or whatever  binary we run does not see anything outside of the jail. It is impossible for instance to remove or read a file outside of the new root folder.\nWe can get an existing ARM rootfs to work with, or we can generate one. In Debian we can use debootstrap with the –arch  switch to generate a Stretch ARM rootfs. $ debootstrap --arch=armhf stretch new_root_folder\nWhat we want to do now is to use chroot to make the binaries inside the jail view the filesystem just like they expect it. By using chroot we already have /etc, /bin and all the regular folders in place. Next, we need to add the virtual filesystems # mount -t proc proc new_root_folder/proc/ # mount -t sysfs sys new_root_folder/sys/ # mount -o bind /dev new_root_folder/dev/ # mount -o bind /dev/pts new_root_folder/dev/pts\nFinally, we will copy the qemu-user-static binary inside the ARM filesystem. # cp /usr/bin/qemu-arm-static new_root_folder/usr/bin\nThis little intruder will be the only x86 binary in an ARM filesystem, he’s surrounded!\nWe have everything in place! What will happen when we try to execute some ARM executable from the jail? The chroot command will call execve() on the ARM binary The ARM binary will be handled by the binfmt_misc binary handler, according to its configured ARM ELF magic. The entry in binfmt_misc instructs the kernel to use /usr/bin/qemu-arm-static as an interpreter, that is why we had to copy it inside the jail. Remember that by chroot magic /usr/bin is really inside new_root_folder. qemu-arm-static will interpret the ARM binary in user mode. We are using the static version of qemu-arm because we need the interpreter to be standalone, as it is the only x86 binary in the jail and will not have access to any x86 libraries. Any ARM library that is expected by the programs inside the jail will be there, as provided by the ARM rootfs.\nLet’s see all this in action, opening a bash shell in a Raspbian rootfs\n\nI had to configure the PATH variable to match the one Raspbian expects. Naturally, our original environment from zsh will be inherited by chroot and arm-bash. We have talked about full system QEMU Raspbian emulation before, and this runs so much faster.\nThings will work as long as the ARM binaries see what they expect to see. Binaries can execve() other executables and everything will mostly work perfectly well. An exception would be programs that use exotic system calls that QEMU user mode still has not implemented yet, for instance for using the pseudo random generator. As QEMU user mode becomes more mature, it is getting more strange to see this happen and normally libraries have fallback options for these situations anyway. In those cases you will see something like qemu: Unsupported syscall: 384\nRemember that we are still using our host kernel, so we can use networking, install packages with apt and all the rest. This is really useful for things like Manipulating rootfs images for other architectures transparently from our x86 workstation. Compiling ARM binaries more easily. Cross-compiling is hard because you need to isolate the libraries and tools that the cross-compiling environment needs with the ones from your workstation. One way of saving some headaches is to emulate native compiling instead of cross compiling. You host can then help natively by setting up a distcc system between jail and host.",
      "lang" : "en"
    } ],
    "author" : [ {
      "type" : [ "h-card" ],
      "properties" : {
        "name" : [ "nachoparker" ],
        "url" : [ "https://ownyourbits.com/author/cisquero_admin/" ]
      },
      "lang" : "en",
      "value" : "nachoparker"
    } ]
  },
  "lang" : "en"
}
