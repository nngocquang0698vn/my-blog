{
  "type" : [ "h-entry" ],
  "properties" : {
    "name" : [ "Accessing go links across tailnets" ],
    "url" : [ "https://willnorris.com/2023/golinks-across-tailnets/" ],
    "published" : [ "2023-11-02T22:31:11-07:00" ],
    "updated" : [ "2023-11-02T22:31:11-07:00" ],
    "content" : [ {
      "html" : "<p>One of the more fun projects I’ve worked on at Tailscale is <a href=\"https://tailscale.com/blog/golink/\">golink</a>,\nwhich provide simple, private shortcuts that you can share with others on your tailnet.\nWe have hundreds of go links at Tailscale that we use on a daily basis.</p>\n<p>But I also run a personal golink server in my homelab with some links that don’t really make sense to add to our corporate golink instance.\nI’d really like to be able to access my personal go links, even when I’m logged in to my work Tailscale profile.\nAnd it turns out, it’s incredibly simple to do.</p>\n<p>Tailscale allows you to <a href=\"https://tailscale.com/kb/1084/sharing/\">share devices</a> to individuals on other tailnets.\nYou can control exactly what level of access those users have in your <a href=\"https://tailscale.com/kb/1018/acls/\">ACLs</a> just like any other user.\nFor the share recipient, they see the device in their list of machines with a “shared in” label.\nBecause the device is in a different tailnet, they can’t use the MagicDNS short name to access it,\nbut they can still use the fully qualified <code>host.tailnetXXXX.ts.net</code> address.</p>\n<p>As I noted previously, I’ve also <a href=\"https://willnorris.com/2023/tailscale-custom-domain/\">setup DNS</a> so that I can access my devices on a custom domain.\nSo my personal golink server is at <code>go.willnorris.net</code>, but still only accessible on my tailnet.\nSo once I’ve shared my golink server to my work account, I can access all of my personal go links using URLs like <code>go.willnorris.net/deploy</code>.\nBut that’s still a lot of typing, and I’d like to have something a little closer to the convenience of the short <code>go</code> hostname.</p>\n<h2 id=\"chaining-go-links\">Chaining go links</h2>\n<p>What I ended up doing is creating a chain of go links on our corporate go link server\nwhich allows any employee to access their personal go links.\nAll go links have a short name and a destination URL.\nThe destination URL can actually use <a href=\"https://pkg.go.dev/text/template\">go templates</a> to do dynamic resolution.\nOne of the variables that the template has access to is <code>.User</code>,\nwhich provides the username (typically an email address) of the user resolving the link.</p>\n<p>So for example, we have a link named <code>go/me</code>, which resolves as:</p>\n<pre tabindex=\"0\"><code>go/me  =&gt;  http://who/{{TrimSuffix .User \"tailscale.com\"}}\n</code></pre><p>This will take the username of the person visiting <code>go/me</code>,\ntrim off the “tailscale.com” from the end of their email address, and send them to our <code>who</code> service.\nSo when I visit <code>go/me</code>, it sends me to <code>http://who/will@</code>, which shows my personal profile in our company directory.\n(This was one of the go links I brought over from my time at Twitter.)</p>\n<p>So back to accessing my personal go link server.\nWe have a very similarly named go link, <code>go/my</code>, which resolves as:</p>\n<pre tabindex=\"0\"><code>go/my  =&gt;  /{{TrimSuffix .User \"@tailscale.com\"}}-go{{with .Path}}/{{.}}{{end}}\n</code></pre><p>Let’s break this down:</p>\n<ul>\n<li>\n<p><code>{{TrimSuffix .User \"@tailscale.com\"}}</code> is almost identical to our <code>go/me</code> link but it strips off the <code>@</code> as well.\nSo when I visit this link, this portion will simply resolve to <code>will</code>.</p>\n</li>\n<li>\n<p><code>-go</code> means that we just add the literal string <code>-go</code>, so now we have <code>will-go</code></p>\n</li>\n<li>\n<p><code>{{with .Path}}/{{.}}{{end}}</code> means that if I added an additional path, we’ll add a slash and then whatever path was specified.\nSo if I visited <code>go/my/deploy</code>, then the <code>deploy</code> would be the extra path that gets added to the end.</p>\n</li>\n</ul>\n<p>There’s one more thing to call out: this destination is a relative URL.\nIt doesn’t have a scheme or a host, it just starts with a <code>/</code>.\nThat means that it gets resolved relative to the current host, which is <code>http://go/</code>.\nThis is how you chain multiple go links together, and it’s actually important that you do it this way.\nSo if I visit <code>http://go/my</code>, using the expansion explained above,\nI would be sent to <code>/will-go</code>, which then expands to the absolute URL <code>http://go/will-go</code>.</p>\n<p>So where does <code>/will-go</code> resolve to? Well, to my personal go link server of course!\nAny Tailscale employee can create a link named <code>{user}-go</code> with their username, and point that at their personal golink server.\nSo for example, I have:</p>\n<pre tabindex=\"0\"><code>go/will-go  =&gt;  http://go.willnorris.net/\n</code></pre><p>I don’t need to use any <code>.Path</code> template variables, since golink will append any extra path by default.\nAnd if I hadn’t setup a custom domain, this could just as easily be <code>http://go.tailXXXX.ts.net</code>.</p>\n<p>So now this means when I visit <code>go/my/deploy</code>, it ends up resolving to <code>http://go.willnorris.net/deploy</code>\nas you can see in this truncated curl output:</p>\n<pre tabindex=\"0\"><code>% curl -isL http://go/my/deploy\n\nHTTP/1.1 302 Found\nLocation: /will-go/deploy\n\nHTTP/1.1 302 Found\nLocation: http://go.willnorris.net/deploy\n\nHTTP/1.1 302 Found\nLocation: https://github.com/willnorris/willnorris.com/actions/workflows/deploy.yml\n</code></pre><h2 id=\"why-relative-links-matter\">Why relative links matter</h2>\n<p>This approach for accessing personal go links involved chaining multiple go links together to get to the final destination.\nThis is also commonly done to create alias go links.\nFor example, you might have <code>go/bugs</code> that links to your bug tracker.\nBut you may also want to have <code>go/b</code>, <code>go/bug</code>, and <code>go/issues</code> link there.\nYou could copy the same destination URL to all of the links, or you could just have the aliases link to the first.</p>\n<pre tabindex=\"0\"><code>go/bugs  =&gt;  http://bugtracker/\n\ngo/b  =&gt;  /bugs\ngo/bug  =&gt;  /bugs\ngo/issues  =&gt;  /bugs\n</code></pre><p>Then, if you ever move your bug tracker, you only need to update the main <code>go/bugs</code> link.\nThis is also helpful to do for go links that have common misspellings.</p>\n<p>So imagine I had created an alias on my personal golink server for <code>go/b</code>.\nBut instead of using a relative link <code>/bugs</code>, I used the absolute URL <code>http://go/bugs</code>.\nNow what happens when I resolve that from my work account using <code>go/my/b</code>?</p>\n<pre tabindex=\"0\"><code>% curl -isL http://go/my/b\n\nHTTP/1.1 302 Found\nLocation: /will-go/b\n\nHTTP/1.1 302 Found\nLocation: http://go.willnorris.net/b\n\nHTTP/1.1 302 Found\nLocation: http://go/bugs\n\nHTTP/1.1 302 Found\nLocation: http://bugs.corp.example.com\n</code></pre><p>When I resolved <code>http://go.willnorris.net/b</code>, it redirected to <code>http://go/bugs</code>.\nBut because I’m logged into my company account, <code>http://go/</code> points to my company golink server,\nwhich then redirects <code>http://go/bugs</code> to the company bug tracker, not my own.\nUsing relative links ensures that chained links are always resolved by the same server.\nThis is also helpful if you name your server something other than <code>go</code>, or you decide to rename it at some point.</p>\n<p>Finally, because I’ve gotten accustomed to using <code>go/my</code> links for my personal links,\nI’ve also setup a <code>go/my</code> link on my personal golink server.\nSince those links should just resolve locally, the destination URL is literally just a slash:</p>\n<pre tabindex=\"0\"><code>go/my  =&gt;  /\n</code></pre><p>So now, if I use <code>go/my/deploy</code> when I’m on my personal Tailscale account,\neven though I could have just used <code>go/deploy</code>, it still gets me there.</p>\n<h2 id=\"nothing-extra-to-build\">Nothing extra to build</h2>\n<p>What’s particularly neat about this approach is that it didn’t require building anything extra.\nDevice sharing, MagicDNS, user identity, and access controls are all just core features of Tailscale.\nThey’re just building blocks you can use to build and access all kinds of services.\nAnd once I had those, it was just a matter of setting up a few go links.</p>",
      "value" : "One of the more fun projects I’ve worked on at Tailscale is golink, which provide simple, private shortcuts that you can share with others on your tailnet. We have hundreds of go links at Tailscale that we use on a daily basis.\nBut I also run a personal golink server in my homelab with some links that don’t really make sense to add to our corporate golink instance. I’d really like to be able to access my personal go links, even when I’m logged in to my work Tailscale profile. And it turns out, it’s incredibly simple to do.\nTailscale allows you to share devices to individuals on other tailnets. You can control exactly what level of access those users have in your ACLs just like any other user. For the share recipient, they see the device in their list of machines with a “shared in” label. Because the device is in a different tailnet, they can’t use the MagicDNS short name to access it, but they can still use the fully qualified host.tailnetXXXX.ts.net address.\nAs I noted previously, I’ve also setup DNS so that I can access my devices on a custom domain. So my personal golink server is at go.willnorris.net, but still only accessible on my tailnet. So once I’ve shared my golink server to my work account, I can access all of my personal go links using URLs like go.willnorris.net/deploy. But that’s still a lot of typing, and I’d like to have something a little closer to the convenience of the short go hostname. Chaining go links\nWhat I ended up doing is creating a chain of go links on our corporate go link server which allows any employee to access their personal go links. All go links have a short name and a destination URL. The destination URL can actually use go templates to do dynamic resolution. One of the variables that the template has access to is .User, which provides the username (typically an email address) of the user resolving the link.\nSo for example, we have a link named go/me, which resolves as: go/me => http://who/{{TrimSuffix .User \"tailscale.com\"}}\nThis will take the username of the person visiting go/me, trim off the “tailscale.com” from the end of their email address, and send them to our who service. So when I visit go/me, it sends me to http://who/will@, which shows my personal profile in our company directory. (This was one of the go links I brought over from my time at Twitter.)\nSo back to accessing my personal go link server. We have a very similarly named go link, go/my, which resolves as: go/my => /{{TrimSuffix .User \"@tailscale.com\"}}-go{{with .Path}}/{{.}}{{end}}\nLet’s break this down:\n{{TrimSuffix .User \"@tailscale.com\"}} is almost identical to our go/me link but it strips off the @ as well. So when I visit this link, this portion will simply resolve to will.\n-go means that we just add the literal string -go, so now we have will-go\n{{with .Path}}/{{.}}{{end}} means that if I added an additional path, we’ll add a slash and then whatever path was specified. So if I visited go/my/deploy, then the deploy would be the extra path that gets added to the end.\nThere’s one more thing to call out: this destination is a relative URL. It doesn’t have a scheme or a host, it just starts with a /. That means that it gets resolved relative to the current host, which is http://go/. This is how you chain multiple go links together, and it’s actually important that you do it this way. So if I visit http://go/my, using the expansion explained above, I would be sent to /will-go, which then expands to the absolute URL http://go/will-go.\nSo where does /will-go resolve to? Well, to my personal go link server of course! Any Tailscale employee can create a link named {user}-go with their username, and point that at their personal golink server. So for example, I have: go/will-go => http://go.willnorris.net/\nI don’t need to use any .Path template variables, since golink will append any extra path by default. And if I hadn’t setup a custom domain, this could just as easily be http://go.tailXXXX.ts.net.\nSo now this means when I visit go/my/deploy, it ends up resolving to http://go.willnorris.net/deploy as you can see in this truncated curl output: % curl -isL http://go/my/deploy HTTP/1.1 302 Found Location: /will-go/deploy HTTP/1.1 302 Found Location: http://go.willnorris.net/deploy HTTP/1.1 302 Found Location: https://github.com/willnorris/willnorris.com/actions/workflows/deploy.yml Why relative links matter\nThis approach for accessing personal go links involved chaining multiple go links together to get to the final destination. This is also commonly done to create alias go links. For example, you might have go/bugs that links to your bug tracker. But you may also want to have go/b, go/bug, and go/issues link there. You could copy the same destination URL to all of the links, or you could just have the aliases link to the first. go/bugs => http://bugtracker/ go/b => /bugs go/bug => /bugs go/issues => /bugs\nThen, if you ever move your bug tracker, you only need to update the main go/bugs link. This is also helpful to do for go links that have common misspellings.\nSo imagine I had created an alias on my personal golink server for go/b. But instead of using a relative link /bugs, I used the absolute URL http://go/bugs. Now what happens when I resolve that from my work account using go/my/b? % curl -isL http://go/my/b HTTP/1.1 302 Found Location: /will-go/b HTTP/1.1 302 Found Location: http://go.willnorris.net/b HTTP/1.1 302 Found Location: http://go/bugs HTTP/1.1 302 Found Location: http://bugs.corp.example.com\nWhen I resolved http://go.willnorris.net/b, it redirected to http://go/bugs. But because I’m logged into my company account, http://go/ points to my company golink server, which then redirects http://go/bugs to the company bug tracker, not my own. Using relative links ensures that chained links are always resolved by the same server. This is also helpful if you name your server something other than go, or you decide to rename it at some point.\nFinally, because I’ve gotten accustomed to using go/my links for my personal links, I’ve also setup a go/my link on my personal golink server. Since those links should just resolve locally, the destination URL is literally just a slash: go/my => /\nSo now, if I use go/my/deploy when I’m on my personal Tailscale account, even though I could have just used go/deploy, it still gets me there. Nothing extra to build\nWhat’s particularly neat about this approach is that it didn’t require building anything extra. Device sharing, MagicDNS, user identity, and access controls are all just core features of Tailscale. They’re just building blocks you can use to build and access all kinds of services. And once I had those, it was just a matter of setting up a few go links.",
      "lang" : "en-us"
    } ],
    "author" : [ {
      "type" : [ "h-card" ],
      "properties" : {
        "name" : [ "Will Norris" ],
        "photo" : [ "https://willnorris.com/logo.jpg" ],
        "url" : [ "https://willnorris.com/" ]
      },
      "lang" : "en-us",
      "value" : "Will Norris"
    } ],
    "comment" : [ {
      "type" : [ "h-entry" ],
      "properties" : {
        "category" : [ "#Technology" ],
        "published" : [ "2023-11-03T17:03:58Z" ],
        "updated" : [ "2023-11-03T17:03:58Z" ],
        "content" : [ {
          "html" : "<p>Golinks seem like a small thing but actually might be the thing that pushes me over the edge to running my own tailnet. </p>\n<p>I like Will's solution here to running multiple otherwise-conflicting golinks servers.</p>\n<p>The whole thing seems powerful and I suppose I should just dive in. <a href=\"https://werd.io/tag/Technology\" class=\"p-category\">#Technology</a></p>",
          "value" : "Golinks seem like a small thing but actually might be the thing that pushes me over the edge to running my own tailnet.\nI like Will's solution here to running multiple otherwise-conflicting golinks servers.\nThe whole thing seems powerful and I suppose I should just dive in. #Technology",
          "lang" : "en-us"
        } ],
        "author" : [ {
          "type" : [ "h-card" ],
          "properties" : {
            "photo" : [ {
              "value" : "https://willnorris.com/api/imageproxy/sXx-6J07na8rL0LUtyX8_D-P_V0htA1fGcWCA8fJkL-E/https://webmention.io/avatar/werd.io/e91155d1604c3a5bf2b196de23cf1c23bb3b1356fd3220897d794120f7e0aacf.jpg",
              "alt" : ""
            } ],
            "name" : [ "Ben Werdmuller" ]
          },
          "lang" : "en-us",
          "value" : "Ben Werdmuller"
        } ]
      },
      "id" : "comment-1734068",
      "lang" : "en-us",
      "value" : "Ben Werdmuller November 3, 2023\nGolinks seem like a small thing but actually might be the thing that pushes me over the edge to running my own tailnet.\nI like Will's solution here to running multiple otherwise-conflicting golinks servers.\nThe whole thing seems powerful and I suppose I should just dive in. #Technology"
    } ]
  },
  "lang" : "en-us"
}
